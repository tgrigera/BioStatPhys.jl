var documenterSearchIndex = {"docs":
[{"location":"stat/#Statistical-tools","page":"Statistical tools","title":"Statistical tools","text":"","category":"section"},{"location":"stat/#Running-mean-and-variance","page":"Statistical tools","title":"Running mean and variance","text":"","category":"section"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"There are plenty of implementations of mean and variance of numbers stored in a vector.  However, sometimes  it is more convenient to maintain running estimates of mean and/or variance, adding new data as it pops up, without storing the whole data set in an array.  One way of achieving this is with recursion formulae proposed by D. H. D. West.","category":"page"},{"location":"stat/#West's-recursion-formulae","page":"Statistical tools","title":"West's recursion formulae","text":"","category":"section"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"These are recursion relations that allow to hold running estimates of mean and variance without storing the data points.  Additionally, they provide a good numerical estimate of the variance (performing as well as the two-pass algorithm without need for a second pass).","category":"page"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"For unweighted data, the formulae are (x_N is the N-th data point, and mu_N and sigma^2_N are the estimates of mean and variance with N points, respectively):","category":"page"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"beginalign*\n  mu_N  = mu_N-1 + frac1N left(x_N -mu_N-1 right) \n  S_N  = S_N-1 + fracN-1N left(x_N -mu_N-1right)^2  sigma^2_N = fracS_NN-1\nendalign*","category":"page"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"The weighted versions (using w_N for the weight of x_N) are:","category":"page"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"beginalign*\n   mu_N  = mu_N-1 + fracw_Nsum_i=1^N w_i left(x_N -mu_N-1 right) \n   S_N = S_N-1 + fracw_N sum_i=1^N-1 w_isum_i=1^N w_i left(x_N -mu_N-1right)^2 \n     sigma^2_N = fracS_NfracN-1Nsum_i=1^N w_i\nendalign*","category":"page"},{"location":"stat/#Reference","page":"Statistical tools","title":"Reference","text":"","category":"section"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"D. H. D. West, Updating mean and variance estimates: an improved method. Communications of the ACM 22, 532 (1979).","category":"page"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"CurrentModule = BioStatPhys","category":"page"},{"location":"stat/#API","page":"Statistical tools","title":"API","text":"","category":"section"},{"location":"stat/#Unweighted-data","page":"Statistical tools","title":"Unweighted data","text":"","category":"section"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"MeanVar\npush!(MV::MeanVar,x)\nmean(MV::MeanVar)\nvar(MV::MeanVar)","category":"page"},{"location":"stat/#BioStatPhys.MeanVar","page":"Statistical tools","title":"BioStatPhys.MeanVar","text":"MeanVar\n\nType to allow running computation of mean and variance (i.e. without storing the data points).\n\nAfter the object is created with MeanVar(), data are fed one at a time with push!, causing the internal state to be updated but without storing the new data point (MeanVar requires a fixed amount of storage: two real numbers and an integer).  Mean and variance estimates from a MeanVar object are obtained calling mean and var.\n\nMeanVar uses West's recursion formula, see\n\nD. H. D. West, Communications of the ACM 22, 532 (1979)\n\nExample\n\nmv=MeanVar()\npush!(mv,a)\npush!(mv,b)\n...\nprintln(\"Mean = $(mean(mv))\")\nprintln(\"Variance = $(var(mv))\")\n\nSee also\n\nSee WMeanVar for the case of weighted data.\n\n\n\n\n\n","category":"type"},{"location":"stat/#Base.push!-Tuple{MeanVar, Any}","page":"Statistical tools","title":"Base.push!","text":"function push!(MV::MeanVar,x)\n\nAdd data point x to MeanVar object MV\n\n\n\n\n\n","category":"method"},{"location":"stat/#BioStatPhys.mean-Tuple{MeanVar}","page":"Statistical tools","title":"BioStatPhys.mean","text":"Compute mean estimate (sample mean) from a MeanVar object\n\n\n\n\n\n","category":"method"},{"location":"stat/#BioStatPhys.var-Tuple{MeanVar}","page":"Statistical tools","title":"BioStatPhys.var","text":"Compute variance estimate (population variance) from a MeanVar object\n\n\n\n\n\n","category":"method"},{"location":"stat/#Weighted-data","page":"Statistical tools","title":"Weighted data","text":"","category":"section"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"WMeanVar","category":"page"},{"location":"stat/#BioStatPhys.WMeanVar","page":"Statistical tools","title":"BioStatPhys.WMeanVar","text":"WMeanVar\n\nType to allow running computation of mean and variance of weighted data (without storing the data points).\n\nThe object is created with WMeanVar(), data are fed one at a time with push!, and mean and variance are obtained calling mean and var.\n\nInterface is the same as for the unweighted version `MeanVar', which see for an example.\n\nWMeanVar uses West's recursion formula, see\n\nD. H. D. West, Communications of the ACM 22, 532 (1979)\n\n\n\n\n\n","category":"type"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"see MeanVar","category":"page"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"push!(MV::WMeanVar,x,w)\nmean(MV::WMeanVar)\nvar(MV::WMeanVar)","category":"page"},{"location":"stat/#Base.push!-Tuple{WMeanVar, Any, Any}","page":"Statistical tools","title":"Base.push!","text":"function push!(WMV::WMeanVar,x)\n\nAdd data point x with weight W to WMeanVar object WMV\n\n\n\n\n\n","category":"method"},{"location":"stat/#BioStatPhys.mean-Tuple{WMeanVar}","page":"Statistical tools","title":"BioStatPhys.mean","text":"Compute mean estimate (sample mean) from a WMeanVar object\n\n\n\n\n\n","category":"method"},{"location":"stat/#BioStatPhys.var-Tuple{WMeanVar}","page":"Statistical tools","title":"BioStatPhys.var","text":"Compute variance estimate (population variance) from a WMeanVar object\n\n\n\n\n\n","category":"method"},{"location":"stat/#Histograms","page":"Statistical tools","title":"Histograms","text":"","category":"section"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"A type for computation of histograms, with track of outliers.  Provides access to bin counts or probabilities.","category":"page"},{"location":"stat/#API-2","page":"Statistical tools","title":"API","text":"","category":"section"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"Histogram\npush!(::Histogram,::AbstractFloat)\noutliers\narea\ncounts\nprob\nmedian","category":"page"},{"location":"stat/#BioStatPhys.Histogram","page":"Statistical tools","title":"BioStatPhys.Histogram","text":"struct Histogram\n\nType to build histograms, based on BinnedVector.  Create a Histogram object with\n\nhis=Histogram(nbis,min=interval_min,max=interval_max)\n\nAdd data with push! and access with area, outliers, prob and counts.\n\n\n\n\n\n","category":"type"},{"location":"stat/#Base.push!-Tuple{Histogram, AbstractFloat}","page":"Statistical tools","title":"Base.push!","text":"push!(his::Histogram,datum::AbstractFloat)\n\nAdd new data point to histogram his\n\n\n\n\n\n","category":"method"},{"location":"stat/#BioStatPhys.outliers","page":"Statistical tools","title":"BioStatPhys.outliers","text":"outliers(his::Histogram)\n\nReturn number of points outside histogram interval.\n\n\n\n\n\n","category":"function"},{"location":"stat/#BioStatPhys.area","page":"Statistical tools","title":"BioStatPhys.area","text":"area(his::Histogram)\n\nCompute total area under histogram within the interval defined at creation.  This interprets histogram as a probability distribution, so that area is bounded by 1.  It can be less than 1 due to outlier points.\n\n\n\n\n\n","category":"function"},{"location":"stat/#BioStatPhys.counts","page":"Statistical tools","title":"BioStatPhys.counts","text":"counts(his::Histogram)\n\nReturn tuple (x,counts) where x is a vector with the position of bin centers and counts is a vector of bin counts.\n\n\n\n\n\n","category":"function"},{"location":"stat/#BioStatPhys.prob","page":"Statistical tools","title":"BioStatPhys.prob","text":"prob(his::Histogram,bin)\n\nReturn probability density for bin, i.e. counts for bin divided by total data points and by the bin width.\n\n\n\n\n\nprob(his::Histogram)\n\nReturn tuple (x,prob) where x is a vector with the position of bin centers and prob is a vector of probability densities.  prob is to be interpreted as needing integration over an appropriate interval, e.g. the sum of prob elements multiplied by the bin with is equal to area(his).\n\n\n\n\n\n","category":"function"},{"location":"stat/#BioStatPhys.median","page":"Statistical tools","title":"BioStatPhys.median","text":"median(his::Histogram)\n\nReturn an approximation to the median as the center of the lowest bin b such that the sum of the low outliers plus the counts of the bins up to b exceeds half the data points.\n\n\n\n\n\n","category":"function"},{"location":"stat/#Time-correlation-functions","page":"Statistical tools","title":"Time correlation functions","text":"","category":"section"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"The time (auto-)correlation function of a signal a(t) (which is a noisy quantity that can be found to take different values if it is measured several times, i.e. it is a stochastic process) is defined as","category":"page"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"  C(t_0t) = langle a^*(t_0) a(t_0+t) rangle","category":"page"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"where a^* is the complex conjugate and brackets stands for a  history-average (an average over many realizations of the stochastic process, i.e. over many repetitions of the experiment, resetting the initial conditions).","category":"page"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"The connected time correlation, or auto-covariance, is","category":"page"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"   C_c(t_0t) = leftlangle delta a^*(t_0) delta a(t_0+t) rightrangle = \n   C(t_0t) - leftlangle a^*(t_0) rightrangle leftlangle a(t_0+t) rightrangle","category":"page"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"where delta a(t)=a(t)-langle a(t) rangle.","category":"page"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"Assume the process a(t) is sampled uniformly in time with interval Delta t.  Calling N the number of time samples and Mthe number of experiments (i.e. different measurements of a(t)  after resetting the initial conditions), we represent these data as M sequences A_i^(n) with i=1ldotsN,  n=1ldotsM.  Then the following statistical estimators of the correlation functions can be computed.","category":"page"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"In the general case,","category":"page"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"beginalign*\n  langle a(t_i) rangle  approx overlineA_i =frac1M sum_n=1^M A_i^(n) \n  C_c(t_it_k)  approx hat C^(c)_ik =frac1Msum_n^M delta A_i^(n)\n  delta A_i+k^(n)   qquad delta A_i^(n) = A_i^(n) - overlineA_i\nendalign*","category":"page"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"If the process a(t) is stationary, then the correlation functions time-translation invariant (i.e. independent of t_0), and an estimate can be obtained with a single sample, averaging over the time origin:","category":"page"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"beginalign*\n  overlineA = frac1Nsum_i=1^N A_i \n  hat C^(c)_k = frac1N-k sum_j=1^N-k delta A_j delta A_j+k\n  qquad\n  delta A_j = A_j - overlineA\nendalign*","category":"page"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"Note that the estimate obtained this way is noisier the larger the value of k.","category":"page"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"If the process is not stationary, then the first estimator, which needs several samples, must be used.  Although we implement this here, note that in the connected case the covariance function cov from the Statistics package can be used instead and is more convenient.  We also implement the estimator for the stationary case.","category":"page"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"For details, and caveats when using these estimators, see the review article","category":"page"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"T. S. Grigera, Correlation functions as a tool to study collective behaviour phenomena in biological systems. J. Phys. Complex. 2, 045016 (2021).  [DOI]","category":"page"},{"location":"stat/#API-3","page":"Statistical tools","title":"API","text":"","category":"section"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"The stationary (or TTI) estimate for a single real or complex sequence is implemented with an algorithm that uses fast-Fourier-transforms, giving O(Nlog N) performance.","category":"page"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"time_correlation","category":"page"},{"location":"stat/#BioStatPhys.time_correlation","page":"Statistical tools","title":"BioStatPhys.time_correlation","text":"time_correlation(A;connected=true,normalized=false,nt=nothing,\n                 i0=nothing,Amean=nothing)\n\nCompute the time (auto-)correlation function for signal A.  Returns a vector C[1:nt]\n\nA: the time signal, assumed to be sampled at evenly-spaced intervals.  If i0==nothing, it must be a Vector (real or complex), which is a single realisation or measurment of the random signal, otherwise it must be a matrix, where columns represent times and rows are different realizations of the random signal.\nIf i0==nothing (default), then A is assumed stationary (or time-translation invariant, TTI), and an estimate employing a single sequence is computed.  Otherwise, it must be an integer in the range 1<=i0<=size(A,2) and is interpreted as an index for the desired reference time.\nconnected: if true, compute the connected (i.e. subtracting the time average) correlation.\nnormalized: if true, return the result normalized by C[1].  Not recommended if non-TTI.\nnt: the maxium time difference to compute in the TTI case, otherwise ignored.  Default size(A,1)÷2.\nAmean: if connected is requested, then the signal mean can be given if now, otherwise it will be computed.\n\nIn the TTI case, an FFT-based implementation is used.\n\nIn the non-TTI, connected, case, it is probably better to use the covariance function of the Statistics package, as cov(A,dims=1).\n\n\n\n\n\n","category":"function"},{"location":"#BioStatPhys","page":"Home","title":"BioStatPhys","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is a collection of various tools for statistical physics analysis of experimental (and in particular biological) data.","category":"page"},{"location":"tools/#Miscellaneous-tools","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"","category":"section"},{"location":"tools/#Real-indexed-vector","page":"Miscellaneous tools","title":"Real-indexed vector","text":"","category":"section"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"This is a simple implementation of a vector that can be accessed with real (floating point) sub-indices.  It does simply a linear binning of a specified (semi-open) interval minmax) on the real line, and provides a convenient Vector-like syntax to access elements.  The stored values can be of any type, but the interval and number of bins are fixed at construction.","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"    push!(LOAD_PATH,homedir()*\"/software/BioStatPhys.jl\"); # hide\n    using BioStatPhys; # hide\n\tA = BinnedVector{String}(5,min=0.,max=1.)\n\tA[0.1]=\"hello\"\n\tA[0.2]=\"bye bye\"\n\tA","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"To initialise elements with a default value, give function with a signature like zeros: ","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"B = BinnedVector{Rational{Int64}}(10,min=2.,max=8.,init=zeros)\nB[2.1]=3//5\nB[5.3]=4//1\nB","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"Indexing with integers refers to bin numbers.","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"\tA[1:2]\n\tB[1:5]","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"Outliers are mapped to bin 0 if below range, or -1 if above range.","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"B[0.]=10//3 ; B[40.]=99//2;\nB[0]\nB[-1]","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"The Histogram type is implemented using BinnedVector.","category":"page"},{"location":"tools/#API","page":"Miscellaneous tools","title":"API","text":"","category":"section"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"BinnedVector\ninterval\ndelta\nnbins\nbin\nbinc","category":"page"},{"location":"tools/#BioStatPhys.BinnedVector","page":"Miscellaneous tools","title":"BioStatPhys.BinnedVector","text":"mutable struct BinnedVector{T}\n\nSimple real-indexed vector.  Maps a real interval to an integer range 1:nbins then used to index a vector of arbitrary type.  Can be used e.g.  to build histograms.  The real interval and number of bins nbins are fixed at the outset.\n\nExample\n\nCreate with\n\nA = BinnedVector{Int}(nbins,min=1.,max=10.,init=zeros)\n\n(init is optional, defaults to leave elements undefined), and access or write as a vector:\n\nA[5.2] += 2\n\nNumbers above and below range map to two special bins.\n\nIf indexed with integers, these are interpreted as bin numbers. A[0] and A[-1] are the outlier bins (below and above, respectively).\n\n\n\n\n\n","category":"type"},{"location":"tools/#BioStatPhys.interval","page":"Miscellaneous tools","title":"BioStatPhys.interval","text":"interval(A::BinnedVector{T})\n\nReturn tuple (min,max) giving the extrema of the real interval mapped to the array bins.\n\n\n\n\n\n","category":"function"},{"location":"tools/#BioStatPhys.delta","page":"Miscellaneous tools","title":"BioStatPhys.delta","text":"delta(A::BinnedVector{T})\n\nReturn the with of the bins of A\n\n\n\n\n\n","category":"function"},{"location":"tools/#BioStatPhys.nbins","page":"Miscellaneous tools","title":"BioStatPhys.nbins","text":"nbins(A::BinnedVector{T})\n\nReturn number of bins of A\n\n\n\n\n\n","category":"function"},{"location":"tools/#BioStatPhys.bin","page":"Miscellaneous tools","title":"BioStatPhys.bin","text":"bin(A::BinnedVector{T},x::Float64) where {T}\n\nMap real value x to bin number.  Return 0 if below range, or -1 if above range.\n\n\n\n\n\n","category":"function"},{"location":"tools/#BioStatPhys.binc","page":"Miscellaneous tools","title":"BioStatPhys.binc","text":"binc(A::BinnedVector{T},i::Int) where {T}\n\nReturn center of bin i, which must be in range 1:size(A,1). Does not perform range check.\n\n\n\n\n\n","category":"function"}]
}
