var documenterSearchIndex = {"docs":
[{"location":"stat/#Statistical-tools","page":"Statistical tools","title":"Statistical tools","text":"","category":"section"},{"location":"stat/#Running-mean-and-variance","page":"Statistical tools","title":"Running mean and variance","text":"","category":"section"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"There are plenty of implementations of mean and variance of numbers stored in a vector.  However, sometimes  it is more convenient to maintain running estimates of mean and/or variance, adding new data as it pops up, without storing the whole data set in an array.  One way of achieving this is with recursion formulae proposed by D. H. D. West.","category":"page"},{"location":"stat/#West's-recursion-formulae","page":"Statistical tools","title":"West's recursion formulae","text":"","category":"section"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"These are recursion relations that allow to hold running estimates of mean and variance without storing the data points.  Additionally, they provide a good numerical estimate of the variance (performing as well as the two-pass algorithm without need for a second pass).","category":"page"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"For unweighted data, the formulae are (x_N is the N-th data point, and mu_N and sigma^2_N are the estimates of mean and variance with N points, respectively):","category":"page"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"beginalign*\n  mu_N  = mu_N-1 + frac1N left(x_N -mu_N-1 right) \n  S_N  = S_N-1 + fracN-1N left(x_N -mu_N-1right)^2  sigma^2_N = fracS_NN-1\nendalign*","category":"page"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"The weighted versions (using w_N for the weight of x_N) are:","category":"page"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"beginalign*\n   mu_N  = mu_N-1 + fracw_Nsum_i=1^N w_i left(x_N -mu_N-1 right) \n   S_N = S_N-1 + fracw_N sum_i=1^N-1 w_isum_i=1^N w_i left(x_N -mu_N-1right)^2 \n     sigma^2_N = fracS_NfracN-1Nsum_i=1^N w_i\nendalign*","category":"page"},{"location":"stat/#Reference","page":"Statistical tools","title":"Reference","text":"","category":"section"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"D. H. D. West, Updating mean and variance estimates: an improved method. Communications of the ACM 22, 532 (1979).","category":"page"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"CurrentModule = BioStatPhys","category":"page"},{"location":"stat/#API","page":"Statistical tools","title":"API","text":"","category":"section"},{"location":"stat/#Unweighted-data","page":"Statistical tools","title":"Unweighted data","text":"","category":"section"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"MeanVar\npush!(MV::MeanVar,x)\nmean(MV::MeanVar)\nvar(MV::MeanVar)","category":"page"},{"location":"stat/#BioStatPhys.MeanVar","page":"Statistical tools","title":"BioStatPhys.MeanVar","text":"MeanVar\n\nType to allow running computation of mean and variance (i.e. without storing the data points).\n\nAfter the object is created with MeanVar(), data are fed one at a time with push!, causing the internal state to be updated but without storing the new data point (MeanVar requires a fixed amount of storage: two real numbers and an integer).  Mean and variance estimates from a MeanVar object are obtained calling mean and var.\n\nMeanVar uses West's recursion formula, see\n\nD. H. D. West, Communications of the ACM 22, 532 (1979)\n\nExample\n\nmv=MeanVar()\npush!(mv,a)\npush!(mv,b)\n...\nprintln(\"Mean = $(mean(mv))\")\nprintln(\"Variance = $(var(mv))\")\n\nSee also\n\nSee WMeanVar for the case of weighted data.\n\n\n\n\n\n","category":"type"},{"location":"stat/#Base.push!-Tuple{MeanVar, Any}","page":"Statistical tools","title":"Base.push!","text":"function push!(MV::MeanVar,x)\n\nAdd data point x to MeanVar object MV\n\n\n\n\n\n","category":"method"},{"location":"stat/#BioStatPhys.mean-Tuple{MeanVar}","page":"Statistical tools","title":"BioStatPhys.mean","text":"Compute mean estimate (sample mean) from a MeanVar object\n\n\n\n\n\n","category":"method"},{"location":"stat/#BioStatPhys.var-Tuple{MeanVar}","page":"Statistical tools","title":"BioStatPhys.var","text":"Compute variance estimate (population variance) from a MeanVar object\n\n\n\n\n\n","category":"method"},{"location":"stat/#Weighted-data","page":"Statistical tools","title":"Weighted data","text":"","category":"section"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"WMeanVar","category":"page"},{"location":"stat/#BioStatPhys.WMeanVar","page":"Statistical tools","title":"BioStatPhys.WMeanVar","text":"WMeanVar\n\nType to allow running computation of mean and variance of weighted data (without storing the data points).\n\nThe object is created with WMeanVar(), data are fed one at a time with push!, and mean and variance are obtained calling mean and var.\n\nInterface is the same as for the unweighted version `MeanVar', which see for an example.\n\nWMeanVar uses West's recursion formula, see\n\nD. H. D. West, Communications of the ACM 22, 532 (1979)\n\n\n\n\n\n","category":"type"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"see MeanVar","category":"page"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"push!(MV::WMeanVar,x,w)\nmean(MV::WMeanVar)\nvar(MV::WMeanVar)","category":"page"},{"location":"stat/#Base.push!-Tuple{WMeanVar, Any, Any}","page":"Statistical tools","title":"Base.push!","text":"function push!(WMV::WMeanVar,x)\n\nAdd data point x with weight W to WMeanVar object WMV\n\n\n\n\n\n","category":"method"},{"location":"stat/#BioStatPhys.mean-Tuple{WMeanVar}","page":"Statistical tools","title":"BioStatPhys.mean","text":"Compute mean estimate (sample mean) from a WMeanVar object\n\n\n\n\n\n","category":"method"},{"location":"stat/#BioStatPhys.var-Tuple{WMeanVar}","page":"Statistical tools","title":"BioStatPhys.var","text":"Compute variance estimate (population variance) from a WMeanVar object\n\n\n\n\n\n","category":"method"},{"location":"stat/#Histograms","page":"Statistical tools","title":"Histograms","text":"","category":"section"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"A type for computation of histograms, with track of outliers.  Provides access to bin counts or probabilities.","category":"page"},{"location":"stat/#API-2","page":"Statistical tools","title":"API","text":"","category":"section"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"Histogram\npush!(::Histogram,::AbstractFloat)\noutliers\narea\ncounts\nprob\nmedian","category":"page"},{"location":"stat/#BioStatPhys.Histogram","page":"Statistical tools","title":"BioStatPhys.Histogram","text":"struct Histogram\n\nType to build histograms, based on BinnedVector.  Create a Histogram object with\n\nhis=Histogram(nbis,min=interval_min,max=interval_max)\n\nAdd data with push! and access with area, outliers, prob and counts.\n\n\n\n\n\n","category":"type"},{"location":"stat/#Base.push!-Tuple{Histogram, AbstractFloat}","page":"Statistical tools","title":"Base.push!","text":"push!(his::Histogram,datum::AbstractFloat)\n\nAdd new data point to histogram his\n\n\n\n\n\n","category":"method"},{"location":"stat/#BioStatPhys.outliers","page":"Statistical tools","title":"BioStatPhys.outliers","text":"outliers(his::Histogram)\n\nReturn number of points outside histogram interval.\n\n\n\n\n\n","category":"function"},{"location":"stat/#BioStatPhys.area","page":"Statistical tools","title":"BioStatPhys.area","text":"area(his::Histogram)\n\nCompute total area under histogram within the interval defined at creation.  This interprets histogram as a probability distribution, so that area is bounded by 1.  It can be less than 1 due to outlier points.\n\n\n\n\n\n","category":"function"},{"location":"stat/#BioStatPhys.counts","page":"Statistical tools","title":"BioStatPhys.counts","text":"counts(his::Histogram)\n\nReturn tuple (x,counts) where x is a vector with the position of bin centers and counts is a vector of bin counts.\n\n\n\n\n\n","category":"function"},{"location":"stat/#BioStatPhys.prob","page":"Statistical tools","title":"BioStatPhys.prob","text":"prob(his::Histogram,bin)\n\nReturn probability density for bin, i.e. counts for bin divided by total data points and by the bin width.\n\n\n\n\n\nprob(his::Histogram)\n\nReturn tuple (x,prob) where x is a vector with the position of bin centers and prob is a vector of probability densities.  prob is to be interpreted as needing integration over an appropriate interval, e.g. the sum of prob elements multiplied by the bin with is equal to area(his).\n\n\n\n\n\n","category":"function"},{"location":"stat/#BioStatPhys.median","page":"Statistical tools","title":"BioStatPhys.median","text":"median(his::Histogram)\n\nReturn an approximation to the median as the center of the lowest bin b such that the sum of the low outliers plus the counts of the bins up to b exceeds half the data points.\n\n\n\n\n\n","category":"function"},{"location":"corr/#Correlation-functions","page":"Correlation functions","title":"Correlation functions","text":"","category":"section"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"The functions in this section compute estimates of several space and time correlation functions.  The precised definitions of the different quantities computed are summarised below.  For more details, caveats and discussion of the correlation functions we refer to the review article by T. S. Grigera[1].","category":"page"},{"location":"corr/#Time-correlations-and-correlation-time","page":"Correlation functions","title":"Time correlations and correlation time","text":"","category":"section"},{"location":"corr/#Time-correlation-function","page":"Correlation functions","title":"Time correlation function","text":"","category":"section"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"The time (auto-)correlation function of a signal a(t) (which is a noisy quantity that can be found to take different values if it is measured several times, i.e. it is a stochastic process) is defined as","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"  C(t_0t) = langle a^*(t_0) a(t_0+t) rangle","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"where a^* is the complex conjugate and brackets stands for a  history-average (an average over many realizations of the stochastic process, i.e. over many repetitions of the experiment, resetting the initial conditions).","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"The connected time correlation, or auto-covariance, is","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"   C_c(t_0t) = leftlangle delta a^*(t_0) delta a(t_0+t) rightrangle = \n   C(t_0t) - leftlangle a^*(t_0) rightrangle leftlangle a(t_0+t) rightrangle","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"where delta a(t)=a(t)-langle a(t) rangle.","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"Assume the process a(t) is sampled uniformly in time with interval Delta t.  Calling N the number of time samples and Mthe number of experiments (i.e. different measurements of a(t)  after resetting the initial conditions), we represent these data as M sequences A_i^(n) with i=1ldotsN,  n=1ldotsM.  Then the following statistical estimators of the correlation functions can be computed.","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"In the general case,","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"beginalign*\n  langle a(t_i) rangle  approx overlineA_i =frac1M sum_n=1^M A_i^(n) \n  C_c(t_it_k)  approx hat C^(c)_ik =frac1Msum_n^M delta A_i^(n)\n  delta A_i+k^(n)   qquad delta A_i^(n) = A_i^(n) - overlineA_i\nendalign*","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"If the process a(t) is stationary, then the correlation functions time-translation invariant (i.e. independent of t_0), and an estimate can be obtained with a single sample, averaging over the time origin:","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"beginalign*\n  overlineA = frac1Nsum_i=1^N A_i \n  hat C^(c)_k = frac1N-k sum_j=1^N-k delta A_j delta A_j+k\n  qquad\n  delta A_j = A_j - overlineA\nendalign*","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"Note that the estimate obtained this way is noisier the larger the value of k.","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"If the process is not stationary, then the first estimator, which needs several samples, must be used.  Although we implement this here, note that in the connected case the covariance function cov from the Statistics package can be used instead and is more convenient.  The present routine is more useful for stationary case.","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"Refer to the review article[1] for more details.","category":"page"},{"location":"corr/#Correlation-time","page":"Correlation functions","title":"Correlation time","text":"","category":"section"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"The correlation time is a time scale that measures how separated in time two measurements must be for them to be significantly decorrelated.  A good, though abstract, definition is","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"  tau = lim_ttoinfty fract-log C_c(t)","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"which picks the slowest (i.e. longest-ranged) exponential decay rate (cf Correlation length).","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"Since this definition is not directly applicable to finite data, several practical alternatives have been proposed[1].  We mention here only those that are currently implemented in BioStatPhys.","category":"page"},{"location":"corr/#Spectral-correlation-time","page":"Correlation functions","title":"Spectral correlation time","text":"","category":"section"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"The spectral correlation time tau_S is defined as the inverse of the frequency omega_0 such that half the spectral content of the Fourier transform of the connected correlation C_c(t) is contained in the interval -omega_0omega_0.  Translated to the time domain, the definition is","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":" int_0^infty dt  fracC_c(t)C_c(0) fracsin ttaut = fracpi4","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"This is computed by correlation_time_spectral.","category":"page"},{"location":"corr/#API","page":"Correlation functions","title":"API","text":"","category":"section"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"The stationary (or TTI) estimate for a single real or complex sequence is implemented with an algorithm that uses fast-Fourier-transforms, giving O(Nlog N) performance.","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"time_correlation\ncorrelation_time_spectral","category":"page"},{"location":"corr/#BioStatPhys.time_correlation","page":"Correlation functions","title":"BioStatPhys.time_correlation","text":"time_correlation(A; connected=true, normalized=false, nt=nothing, i0=nothing, Amean=nothing)\n\nCompute the time (auto-)correlation function for signal A.  Returns a vector C[1:nt]\n\nA: the time signal, assumed to be sampled at evenly-spaced intervals.  If i0==nothing, it must be a Vector (real or complex), which is a single realisation or measurment of the random signal, otherwise it must be a matrix, where columns represent times and rows are different realizations of the random signal.\nIf i0==nothing (default), then A is assumed stationary (or time-translation invariant, TTI), and an estimate employing a single sequence is computed.  Otherwise, it must be an integer in the range 1<=i0<=size(A,2) and is interpreted as an index for the desired reference time.\nconnected: if true, compute the connected (i.e. subtracting the time average) correlation.\nnormalized: if true, return the result normalized by C[1].  Not recommended if non-TTI.\nnt: the maxium time difference to compute in the TTI case, otherwise ignored.  Default size(A,1)÷2.\nAmean: if connected is requested, then the signal mean can be given if known, otherwise it will be computed.\n\nIn the TTI case, an FFT-based implementation is used.\n\nIn the non-TTI, connected, case, it is probably better to use the covariance function of the Statistics package, as cov(A,dims=1).\n\n\n\n\n\n","category":"function"},{"location":"corr/#BioStatPhys.correlation_time_spectral","page":"Correlation functions","title":"BioStatPhys.correlation_time_spectral","text":"correlation_time_spectral(C,Δt)\n\nCompute the spectral correlation time tau from the connected time correlation C (e.g. as computed by time_correlation).  The scalar Δt is the time step for the sampling of C.\n\nThe exact definition tau is\n\n int_0^infty dt  fracC_c(t)C_c(0) fracsin ttaut = fracpi4\n\n\n\n\n\n","category":"function"},{"location":"corr/#Density-correlations","page":"Correlation functions","title":"Density correlations","text":"","category":"section"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"Here we consider point-like particles in continuous space.  The (instantaneous) density of a given configuration mathbfr_i is","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"beginequation*\nrho(mathbfr) = sum_i=1^N delta(mathbfr-mathbfr_i)\nendequation*","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"where delta(mathbfr) is Dirac's delta.  The density-density correlation function is","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":" G(mathbfrmathbfr_0) = langle rho(mathbfr_0) rho(mathbfr_0+mathbfr)rangle = leftlangle sum_ij delta(mathbfr_0-mathbfr_i)delta(mathbfr_0+mathbfr-mathbfr_i) rightrangle =\nfrac1V leftlangle sum_ij delta(mathbfr-(mathbfr_i-mathbfr_j)) rightrangle ","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"where the last equality holds for homogeneous systems.  The angle brackets denote an ensemble average, i.e. an average over configurations weighted with the appropriate probability distribution (e.g. Boltzmann's distribution in a physical system in equilibrium).","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"The routines in this section compute the density-density correlation function and a couple of other, related and very often used, correlation functions, for the case of homogeneous and isotropic systems in several geometries.","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"The other correlation functions computed are the radial distribution function","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"g(r) = frac1rho^2G(r) - fracdelta(r)4pirho r^2\n = frac1rho N leftlangle sum_ij deltaleft( r - r_ijright) rightrangle","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"and the correlation integral","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":" C(r) = fracrhoN int_0^r G(r)dr = frac1N^2 leftlangle sum_ij Theta(r-r_ij) rightrangle","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"where Theta(r) is Heavisde's function.","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"The computation is done in two steps.  First an internal DensityCorrelation object is built from a set of configurations, then the desired correlation is computed passing this object.  The first step is slow (O(N^2)), while the second is fast.  To build the DensityCorrelation object one needs to load one configuration in a vector of vectors and define the region (see Regions) in which the particles lie, then call density_correlation, specifying the desired range and resolution.  If more configurations are available, they can be added by calls to density_correlation!.  Finally, the desired correlation function is computed.  For example:","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"pos = load_conf()\nregion = Rectangle(pos)\ndc = density_correlation(region,pos,0.1,rmax=10.)\nwhile more_confs()\n   pos = load_conf()\n   density_correlation!(dc,pos)\nend\ngr, Cr = rdf(pc)","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"The DensityCorrelation object is not altered by calling rdf and the like, so that more statics can be added by further calls to density_correlation.  Internally, different subtypes of DensityCorrelation are used for different regions, so that the different cases are handled correctly.  In particular, for non-periodic regions, the unweighted Hanisch [4][1] method is used.","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"Configurations are interpreted as a vector of vectors, where each element is a vector of the size equal to the dimension of the region being used.  The functions expect AbstactVectors, so for example both Vector{Vector{Float64} and Vector{SVector{2,Float64}} are valid types for a 2-dimensional region, but the latter (using StaticArrays) can be much more efficient.","category":"page"},{"location":"corr/#API-2","page":"Correlation functions","title":"API","text":"","category":"section"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"density_correlation\ndensity_correlation!\nrdf","category":"page"},{"location":"corr/#BioStatPhys.density_correlation","page":"Correlation functions","title":"BioStatPhys.density_correlation","text":"density_correlation(region,pos;Δr,rmax)\n\nReturn a Density_correlation object for the given region and configuration pos, with resolution Δr and maximum range rmax. The returned object can be passed to the functions that compute the final correlations, such as rdf, or more configurations can be added to it by calling density_correlation(::DensityCorrelation,pos).\n\npos must be a vector of vectors, i.e. each element of pos must be a vector of the appropriate dimensionality.  Performance advantage may be obtained using StaticArrays to represent individual positions. More precisely, the type of pos is\n\nAbstractVector{T} where T<:AbstractVector{W} where W<:Number\n\n\n\n\n\n","category":"function"},{"location":"corr/#BioStatPhys.density_correlation!","page":"Correlation functions","title":"BioStatPhys.density_correlation!","text":"density_correlation!(dcorr::Density_correlation{R},pos) where R <: Region\n\nUse configuration pos to add statistics to the DensityCorrelation object dcorr.\n\n\n\n\n\n","category":"function"},{"location":"corr/#BioStatPhys.rdf","page":"Correlation functions","title":"BioStatPhys.rdf","text":"rdf(dcorr::Density_correlation{R})\n\nCompute the radial distribution function g(r) and the correlation integral C(r).  Both are returned as a tuple of ZBinnedVector.\n\n\n\n\n\n","category":"function"},{"location":"corr/#Space-correlations-and-correlation-length","page":"Correlation functions","title":"Space correlations and correlation length","text":"","category":"section"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"The space correlation functions of a space-dependent quantity a(mathbfr) are defined as","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"beginalign*\n   C(mathbfr)  = leftlangle a(mathbfr_0) a(mathbfr_0+mathbfr) rightrangle\n   C_c(mathbfr)  = leftlangle delta a(mathbfr_0) delta a(mathbfr_0+mathbfr) rightrangle\nendalign*","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"where delta a(mathbfr) = a(mathbfr) - langle arangle and we are assuming the system is homogeneous (i.e. translation-invariant).  C_c(mathbfr) is called connected correlation in the physics literature, or auto covariance in the mathematical statistics literature.","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"The space_correlation function computes the estimate of C(r) for an isotropic discrete system,","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"beginalign*\n  hat C_c(r)  = fracsum_ij delta a_i delta a_j\n    delta(r-r_ij)  sum_kl delta(r-r_kl)\nendalign*","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"The average langle arangle can be estimated with space average or phase average (see below and the review[1] for details).","category":"page"},{"location":"corr/#Correlation-length","page":"Correlation functions","title":"Correlation length","text":"","category":"section"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"The correlation length is a length scale that measures how far apart two points in space must be taken for them to be significantly decorrelated.  A good, though abstract, definition is","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"  xi = lim_rtoinfty fracr-log C_c(r)","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"which picks the slowest (i.e. longest-ranged) exponential decay rate (cf. Correlation time).","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"Since this definition is not directly applicable to finite data, several alternatives have been proposed, more suited to experimental or numerical determination but respecting the functional dependence with control parameters[1].  We mention here only those that are currently implemented in BioStatPhys.","category":"page"},{"location":"corr/#r_0","page":"Correlation functions","title":"r_0","text":"","category":"section"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"If the connected correlation has been computed with space averaging, C_c(r) will have at least one zero, and the location r_0 of the first of these can be used as a proxy of xi.  We stress that r_0 is not a correlation length, but a useful scale in the case the correlation can be measured for different system sizes L (or in observation windows of different size[2]).  r_0 scales with size as[3]","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"  beginalign*\n    r_0 sim xi log(Lxi)  Lggxi \n    r_0  sim L  Lll xi\n  endalign*","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"The second situation will always be the case in scale-free systems where xi=infty.  See correlation_length_r0.","category":"page"},{"location":"corr/#API-3","page":"Correlation functions","title":"API","text":"","category":"section"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"space_correlation\ncorrelation_length_r0","category":"page"},{"location":"corr/#BioStatPhys.space_correlation","page":"Correlation functions","title":"BioStatPhys.space_correlation","text":"space_correlation(binning::DistanceBinning, X; connected=true, normalized=false, Xmean=nothing)\n\nCompute space correlation of scalar signal X in an isotropic, space-translation-invariant system using the given DistanceBinning. Since the system is assumed to be isotropic and homogeneous, correlations should depend only on the distances among the pairs, so return a tuple (r,C) where r is a vector of distances and C the correlation function at the corresponding distance.\n\nPositions are assumed to be fixed in all configurations, with only the signal changing value.\n\nX: a matrix where each column holds the signal at different positions in space and at a given time.  All columns are used to average the correlation estimate over configurations.\nbinning: instead of positions, this function expects a pre-built DistanceBinning object holding lists of pairs separated by distances in the given range, such as the binnings created by distance_binning.\nconnected: If true, compute the connected correlation, i.e. subtracting the mean of the signal.  If Xmean is nothing, space-averaging is used, i.e. at each configuration (column) the mean of X is computed and subtracted.  For phase averaging, give a precomputed mean in Xmean.\nnormalized: If true, normalize by C(r=0).\n\n\n\n\n\n","category":"function"},{"location":"corr/#BioStatPhys.correlation_length_r0","page":"Correlation functions","title":"BioStatPhys.correlation_length_r0","text":"correlation_length_r0(r,C)\n\nCompute the correlation length proxy r_0 from C_c(r) given as vectors r and C (as obtained e.g. from space_correlation(@ref).\n\nNote that r_0 is not a correlation length, just a proxy that scales with system size L as log L or L if the actual correlation length is much shorter or much larger than L respectively.\n\n\n\n\n\n","category":"function"},{"location":"corr/#References","page":"Correlation functions","title":"References","text":"","category":"section"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"[1]: T. S. Grigera, Correlation functions as a tool to study  collective behaviour phenomena in biological  systems. J. Phys. Complex. 2, 045016 (2021).  [DOI].  This review  discusses the correlation functions and estimators computed by  the routines documented here and is the general reference for  this section.","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"[2]: D. A. Martin, T. L. Ribeiro, S. A. Cannas, T. S. Grigera,  D. Plenz, and D. R. Chialvo. Box scaling as a proxy of finite  size correlations. Sci Rep 11, 15937. (2021)  [DOI]","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"[3]: A. Cavagna, I. Giardina, and T. S.  Grigera. The physics of  flocking: Correlation as a compass from experiments to  theory. Physics Reports 728, 1–62  (2018). [DOI]","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"[4]: K. H. Hanisch, Some remarks on estimators of the distribution  function of nearest neighbour distance in stationary spatial  point processes. Ser. Stat. 15, 409 (1984). [DOI]","category":"page"},{"location":"#BioStatPhys","page":"Home","title":"BioStatPhys","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is a collection of various tools for statistical physics analysis of experimental (and in particular biological) data.","category":"page"},{"location":"tools/#Miscellaneous-tools","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"","category":"section"},{"location":"tools/#Real-indexed-vector","page":"Miscellaneous tools","title":"Real-indexed vector","text":"","category":"section"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"This is a simple implementation of a vector that can be accessed with real (floating point) sub-indices.  It does simply a linear binning of a specified (semi-open) interval minmax) on the real line, and provides a convenient Vector-like syntax to access elements.  The stored values can be of any type, but the interval and number of bins are fixed at construction.","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"    push!(LOAD_PATH,homedir()*\"/software/BioStatPhys.jl\"); # hide\n    using BioStatPhys; # hide\n\tA = BinnedVector{String}(5,min=0.,max=1.)\n\tA[0.1]=\"hello\"\n\tA[0.2]=\"bye bye\"\n\tA","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"To initialise elements with a default value, give function with a signature like zeros: ","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"B = BinnedVector{Rational{Int64}}(10,min=2.,max=8.,init=zeros)\nB[2.1]=3//5\nB[5.3]=4//1\nB","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"Alternatively, it is possible to construct specifying bin width and the interval.  In this case, one of the values will need to be rounded to get an integer number of bins:","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"\tC = BinnedVector{Int}(Δ=0.15,min=5.,max=10.,round_Δ=RoundUp); (C.Δ, interval(C))\n\tD = BinnedVector{Int}(Δ=0.15,min=5.,max=10.,round_max=RoundUp); (D.Δ, interval(D))\n\tE = BinnedVector{Int}(Δ=0.15,min=5.,max=10.,round_min=RoundUp); (E.Δ, interval(E))","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"RoundDown is also recognised.","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"Indexing with integers refers to bin numbers.","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"\tA[1:2]\n\tB[1:5]","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"Outliers are mapped to bin 0 if below range, or -1 if above range.","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"B[0.]=10//3 ; B[40.]=99//2;\nB[0]\nB[-1]","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"As an example of use, the Histogram type is implemented using BinnedVector.","category":"page"},{"location":"tools/#Special-treatment-of-zero","page":"Miscellaneous tools","title":"Special treatment of zero","text":"","category":"section"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"In some cases, like when computing space correlation functions, it is convenient to treat the case A[0.] separately from the bin that starts at 0.  This is what the ZBinnedvector type does.","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"Z = ZBinnedVector{Int}(Δ=0.2,max=0.5,round_max=RoundUp,init=zeros)\nZ[0.] += 10\nZ[0.1] += 10\nZ[0.15] += 10\nZ","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"Note that there is no min argument in the construction of ZBinnedvector, since it is always zero.  In other respects, ZBinnedvector behaves like BinnedVector, except that bin centres are not equally spaced: the first (pesudo-bin) is at 0, the next bin centre is delta(Z)/2, and the rest are delta(Z) units apart.","category":"page"},{"location":"tools/#API","page":"Miscellaneous tools","title":"API","text":"","category":"section"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"BinnedVector\nZBinnedVector\ninterval\ndelta\nnbins\nbin\nbinc\nBase.range(::BinnedVector)","category":"page"},{"location":"tools/#BioStatPhys.BinnedVector","page":"Miscellaneous tools","title":"BioStatPhys.BinnedVector","text":"BinnedVector{T}\n\nSimple real-indexed vector.  Maps a real interval to an integer range 1:nbins then used to index a vector of arbitrary type.  Can be used e.g.  to build histograms.  The real interval and number of bins nbins are fixed at the outset.\n\nExample\n\nCreate with\n\nA = BinnedVector{Int}(nbins,min=1.,max=10.,init=zeros)\n\nfor fixed number of bins, or\n\nA = BinnedVector{Int}(;Δ=0.1,min=1.,max=10.init=zeros,round_Δ=RoundUp)\nA = BinnedVector{Int}(;Δ=0.1,min=1.,max=10.init=zeros,round_min=RoundUp)\nA = BinnedVector{Int}(;Δ=0.1,min=1.,max=10.init=zeros,round_max=RoundUp)\n\nto get fixed (min, max), (Δ,max) or (min,Δ) respectively (rounding mode RoundDown is also recognised).\n\ninit is optional, defaults to leave elements undefined.\n\nAccess or write as a vector:\n\nA[5.2] += 2\n\nNumbers above and below range map to two special bins.\n\nIf indexed with integers, these are interpreted as bin numbers. A[0] and A[-1] are the outlier bins (below and above, respectively).\n\n\n\n\n\n","category":"type"},{"location":"tools/#BioStatPhys.ZBinnedVector","page":"Miscellaneous tools","title":"BioStatPhys.ZBinnedVector","text":"ZBinnedVector{T}\n\nThis type works like BinnedVector{T} except that the range always starts with 0., and that the 0. is treated specially.  The first bin excludes the zero (i.e., unlike the rest of the bins is an open interval on both sides), and the values indexed with 0. are treated separately.  When using integer indices, index 1 corresponds to 0., index 2 to the first bin, and so on.\n\nThis is useful when dealing for example with space correlation functions, where a zero distance implies a correlation of a particle with itself, which is often convenient to treat separately from the inter-particle correlations.\n\n\n\n\n\n","category":"type"},{"location":"tools/#BioStatPhys.interval","page":"Miscellaneous tools","title":"BioStatPhys.interval","text":"interval(A::BinnedVector{T})\ninterval(A::ZBinnedVector{T})\n\nReturn tuple (min,max) giving the extrema of the real interval mapped to the array bins.\n\n\n\n\n\n","category":"function"},{"location":"tools/#BioStatPhys.delta","page":"Miscellaneous tools","title":"BioStatPhys.delta","text":"delta(A::BinnedVector{T})\ndelta(A::ZBinnedVector{T})\n\nReturn the with of the bins of A\n\n\n\n\n\n","category":"function"},{"location":"tools/#BioStatPhys.nbins","page":"Miscellaneous tools","title":"BioStatPhys.nbins","text":"nbins(A::BinnedVector{T})\nnbins(A::ZBinnedVector{T})\n\nReturn number of bins of A\n\n\n\n\n\n","category":"function"},{"location":"tools/#BioStatPhys.bin","page":"Miscellaneous tools","title":"BioStatPhys.bin","text":"bin(A::BinnedVector{T},x::Float64) where {T}\nbin(A::ZBinnedVector{T},x::Float64) where {T}\n\nMap real value x to bin number.  Return 0 if below range, or -1 if above range.\n\n\n\n\n\n","category":"function"},{"location":"tools/#BioStatPhys.binc","page":"Miscellaneous tools","title":"BioStatPhys.binc","text":"binc(A::BinnedVector{T},i::Int) where {T} \nbinc(A::ZBinnedVector{T},i::Int) where {T}\n\nReturn center of bin i, which must be in range 1:size(A,1). Does not perform range check.\n\n\n\n\n\nbinc(his::Histogram,bin)\n\nReturn position of center of bin bin.  No range check performed.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Base.range-Tuple{BinnedVector}","page":"Miscellaneous tools","title":"Base.range","text":"Base.range(A::BinnedVector{T}) where{T}\nBase.range(A::ZBinnedVector{T}) where{T}\n\nReturn iterator spanning bin centers of A.  With r=collect(range(A)) one obtains a Vector such that r[i]=binc(A,i).\n\nFor BinnedVector this is a standard range, for ZBinnedVector it is a range-compatible custom iterator since the distance from 0. to the first bin center is half the distance between bin centers.\n\n\n\n\n\n","category":"method"},{"location":"tools/#Distance-binning","page":"Miscellaneous tools","title":"Distance binning","text":"","category":"section"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"The distance_binning function takes a series of points in (2- or 3-d) space and creates a BinnedVector that classifies the pairs according to their Euclidean distance.","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"DistanceBinning\ndistance_binning","category":"page"},{"location":"tools/#BioStatPhys.DistanceBinning","page":"Miscellaneous tools","title":"BioStatPhys.DistanceBinning","text":"Alias for a BinnedVector of Vector{Tuple{Int,Int}}\n\n\n\n\n\n","category":"type"},{"location":"tools/#BioStatPhys.distance_binning","page":"Miscellaneous tools","title":"BioStatPhys.distance_binning","text":"distance_binning(pos,Δr;rmin=0.,rmax=nothing)\n\nCreate a BinnedVector of tuples (i,j) with i!=j, where each bin contains all pairs of positions in pos whose distance is within the bin extrema.\n\npos is expected to be a Matrix where each row pos[i,:] is a 2-d or 3-d position vector.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Regions","page":"Miscellaneous tools","title":"Regions","text":"","category":"section"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"Types and functions to describe periodic and non-periodic regions of space.","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"Region\nRectangle\nPeriodicHyperCube\nPeriodicRectangle\nPeriodicCube\ndimension\nvolume\ndborder\ndistancesq","category":"page"},{"location":"tools/#BioStatPhys.Region","page":"Miscellaneous tools","title":"BioStatPhys.Region","text":"abstract type Region\n\nBase type for regions.\n\n\n\n\n\n","category":"type"},{"location":"tools/#BioStatPhys.Rectangle","page":"Miscellaneous tools","title":"BioStatPhys.Rectangle","text":"Rectangle <: NonPeriodicRegion\n\nDescribes a rectangular non-periodic 2-d region with an arbitrary origin and size.\n\n\n\n\n\n","category":"type"},{"location":"tools/#BioStatPhys.PeriodicHyperCube","page":"Miscellaneous tools","title":"BioStatPhys.PeriodicHyperCube","text":"PeriodicHyperCube{D} <: PeriodicRegion\n\nDescribes a periodic D-dimensional region.  Actually the size along each dimension can be different.\n\n\n\n\n\n","category":"type"},{"location":"tools/#BioStatPhys.PeriodicRectangle","page":"Miscellaneous tools","title":"BioStatPhys.PeriodicRectangle","text":"PeriodicRectangle <: PeriodicRegion\n\nDescribes periodic rectangular 2-d region with arbitrary size.  Alias for PeriodicHyperCube{2}.\n\n\n\n\n\n","category":"type"},{"location":"tools/#BioStatPhys.PeriodicCube","page":"Miscellaneous tools","title":"BioStatPhys.PeriodicCube","text":"PeriodicCube(Lx,Ly,Lz)\n\nReturn a periodic cube (actually rectangular cuboid).  Alias for PeriodicHyperCube{3}\n\n\n\n\n\n","category":"type"},{"location":"tools/#BioStatPhys.dimension","page":"Miscellaneous tools","title":"BioStatPhys.dimension","text":"dimension(r<:Region)\n\nReturn the dimension of region r, in the sense of dimension of a space or a manifold.\n\n\n\n\n\n","category":"function"},{"location":"tools/#BioStatPhys.volume","page":"Miscellaneous tools","title":"BioStatPhys.volume","text":"Return the volume of the given region\n\n\n\n\n\n","category":"function"},{"location":"tools/#BioStatPhys.dborder","page":"Miscellaneous tools","title":"BioStatPhys.dborder","text":"dborder(r<:NonPeriodicRegion,p::AbstractVector)\n\nReturn the distance from the point p (assumed included in region r) to the nearest border.\n\n\n\n\n\n","category":"function"},{"location":"tools/#BioStatPhys.distancesq","page":"Miscellaneous tools","title":"BioStatPhys.distancesq","text":"distancesq(r<:PeriodicRegion,x::AbstractVector{<:Number},y::AbstractVector{<:Number})\n\nReturn the periodic squared distance between points x and y in the periodic region r\n\n\n\n\n\n","category":"function"}]
}
