var documenterSearchIndex = {"docs":
[{"location":"stat/#Statistical-tools","page":"Statistical tools","title":"Statistical tools","text":"","category":"section"},{"location":"stat/#Running-mean-and-variance","page":"Statistical tools","title":"Running mean and variance","text":"","category":"section"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"There are plenty of implementations of mean and variance of numbers stored in a vector.  However, sometimes  it is more convenient to maintain running estimates of mean and/or variance, adding new data as it pops up, without storing the whole data set in an array.  One way of achieving this is with recursion formulae proposed by D. H. D. West.","category":"page"},{"location":"stat/#West's-recursion-formulae","page":"Statistical tools","title":"West's recursion formulae","text":"","category":"section"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"These are recursion relations that allow to hold running estimates of mean and variance without storing the data points.  Additionally, they provide a good numerical estimate of the variance (performing as well as the two-pass algorithm without need for a second pass).","category":"page"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"For unweighted data, the formulae are (x_N is the N-th data point, and mu_N and sigma^2_N are the estimates of mean and variance with N points, respectively):","category":"page"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"beginalign*\n  mu_N  = mu_N-1 + frac1N left(x_N -mu_N-1 right) \n  S_N  = S_N-1 + fracN-1N left(x_N -mu_N-1right)^2  sigma^2_N = fracS_NN-1\nendalign*","category":"page"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"The weighted versions (using w_N for the weight of x_N) are:","category":"page"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"beginalign*\n   mu_N  = mu_N-1 + fracw_Nsum_i=1^N w_i left(x_N -mu_N-1 right) \n   S_N = S_N-1 + fracw_N sum_i=1^N-1 w_isum_i=1^N w_i left(x_N -mu_N-1right)^2 \n     sigma^2_N = fracS_NfracN-1Nsum_i=1^N w_i\nendalign*","category":"page"},{"location":"stat/#Reference","page":"Statistical tools","title":"Reference","text":"","category":"section"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"D. H. D. West, Updating mean and variance estimates: an improved method. Communications of the ACM 22, 532 (1979).","category":"page"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"CurrentModule = BioStatPhys","category":"page"},{"location":"stat/#API","page":"Statistical tools","title":"API","text":"","category":"section"},{"location":"stat/#Unweighted-data","page":"Statistical tools","title":"Unweighted data","text":"","category":"section"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"MeanVar\npush!(MV::MeanVar,x)\nmean(MV::MeanVar)\nvar(MV::MeanVar)","category":"page"},{"location":"stat/#BioStatPhys.MeanVar","page":"Statistical tools","title":"BioStatPhys.MeanVar","text":"MeanVar\n\nType to allow running computation of mean and variance (i.e. without storing the data points).\n\nAfter the object is created with MeanVar(), data are fed one at a time with push!, causing the internal state to be updated but without storing the new data point (MeanVar requires a fixed amount of storage: two real numbers and an integer).  Mean and variance estimates from a MeanVar object are obtained calling mean and var.\n\nMeanVar uses West's recursion formula, see\n\nD. H. D. West, Communications of the ACM 22, 532 (1979)\n\nExample\n\nmv=MeanVar()\npush!(mv,a)\npush!(mv,b)\n...\nprintln(\"Mean = $(mean(mv))\")\nprintln(\"Variance = $(var(mv))\")\n\nSee also\n\nSee WMeanVar for the case of weighted data.\n\n\n\n\n\n","category":"type"},{"location":"stat/#Base.push!-Tuple{MeanVar, Any}","page":"Statistical tools","title":"Base.push!","text":"function push!(MV::MeanVar,x)\n\nAdd data point x to MeanVar object MV\n\n\n\n\n\n","category":"method"},{"location":"stat/#BioStatPhys.mean-Tuple{MeanVar}","page":"Statistical tools","title":"BioStatPhys.mean","text":"Compute mean estimate (sample mean) from a MeanVar object\n\n\n\n\n\n","category":"method"},{"location":"stat/#BioStatPhys.var-Tuple{MeanVar}","page":"Statistical tools","title":"BioStatPhys.var","text":"Compute variance estimate (population variance) from a MeanVar object\n\n\n\n\n\n","category":"method"},{"location":"stat/#Weighted-data","page":"Statistical tools","title":"Weighted data","text":"","category":"section"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"WMeanVar","category":"page"},{"location":"stat/#BioStatPhys.WMeanVar","page":"Statistical tools","title":"BioStatPhys.WMeanVar","text":"WMeanVar\n\nType to allow running computation of mean and variance of weighted data (without storing the data points).\n\nThe object is created with WMeanVar(), data are fed one at a time with push!, and mean and variance are obtained calling mean and var.\n\nInterface is the same as for the unweighted version `MeanVar', which see for an example.\n\nWMeanVar uses West's recursion formula, see\n\nD. H. D. West, Communications of the ACM 22, 532 (1979)\n\n\n\n\n\n","category":"type"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"see MeanVar","category":"page"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"push!(MV::WMeanVar,x,w)\nmean(MV::WMeanVar)\nvar(MV::WMeanVar)","category":"page"},{"location":"stat/#Base.push!-Tuple{WMeanVar, Any, Any}","page":"Statistical tools","title":"Base.push!","text":"function push!(WMV::WMeanVar,x)\n\nAdd data point x with weight W to WMeanVar object WMV\n\n\n\n\n\n","category":"method"},{"location":"stat/#BioStatPhys.mean-Tuple{WMeanVar}","page":"Statistical tools","title":"BioStatPhys.mean","text":"Compute mean estimate (sample mean) from a WMeanVar object\n\n\n\n\n\n","category":"method"},{"location":"stat/#BioStatPhys.var-Tuple{WMeanVar}","page":"Statistical tools","title":"BioStatPhys.var","text":"Compute variance estimate (population variance) from a WMeanVar object\n\n\n\n\n\n","category":"method"},{"location":"stat/#Histograms","page":"Statistical tools","title":"Histograms","text":"","category":"section"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"A type for computation of histograms, with track of outliers.  Provides access to bin counts or probabilities.","category":"page"},{"location":"stat/#API-2","page":"Statistical tools","title":"API","text":"","category":"section"},{"location":"stat/","page":"Statistical tools","title":"Statistical tools","text":"Histogram\npush!(::Histogram,::AbstractFloat)\noutliers\narea\ncounts\nprob\nmedian","category":"page"},{"location":"stat/#BioStatPhys.Histogram","page":"Statistical tools","title":"BioStatPhys.Histogram","text":"struct Histogram\n\nType to build histograms, based on BinnedVector.  Create a Histogram object with\n\nhis=Histogram(nbis,min=interval_min,max=interval_max)\n\nAdd data with push! and access with area, outliers, prob and counts.\n\n\n\n\n\n","category":"type"},{"location":"stat/#Base.push!-Tuple{Histogram, AbstractFloat}","page":"Statistical tools","title":"Base.push!","text":"push!(his::Histogram,datum::AbstractFloat)\n\nAdd new data point to histogram his\n\n\n\n\n\n","category":"method"},{"location":"stat/#BioStatPhys.outliers","page":"Statistical tools","title":"BioStatPhys.outliers","text":"outliers(his::Histogram)\n\nReturn number of points outside histogram interval.\n\n\n\n\n\n","category":"function"},{"location":"stat/#BioStatPhys.area","page":"Statistical tools","title":"BioStatPhys.area","text":"area(his::Histogram)\n\nCompute total area under histogram within the interval defined at creation.  This interprets histogram as a probability distribution, so that area is bounded by 1.  It can be less than 1 due to outlier points.\n\n\n\n\n\n","category":"function"},{"location":"stat/#BioStatPhys.counts","page":"Statistical tools","title":"BioStatPhys.counts","text":"counts(his::Histogram)\n\nReturn tuple (x,counts) where x is a vector with the position of bin centers and counts is a vector of bin counts.\n\n\n\n\n\n","category":"function"},{"location":"stat/#BioStatPhys.prob","page":"Statistical tools","title":"BioStatPhys.prob","text":"prob(his::Histogram,bin)\n\nReturn probability density for bin, i.e. counts for bin divided by total data points and by the bin width.\n\n\n\n\n\nprob(his::Histogram)\n\nReturn tuple (x,prob) where x is a vector with the position of bin centers and prob is a vector of probability densities.  prob is to be interpreted as needing integration over an appropriate interval, e.g. the sum of prob elements multiplied by the bin with is equal to area(his).\n\n\n\n\n\n","category":"function"},{"location":"stat/#BioStatPhys.median","page":"Statistical tools","title":"BioStatPhys.median","text":"median(his::Histogram)\n\nReturn an approximation to the median as the center of the lowest bin b such that the sum of the low outliers plus the counts of the bins up to b exceeds half the data points.\n\n\n\n\n\n","category":"function"},{"location":"corr/#Correlation-functions","page":"Correlation functions","title":"Correlation functions","text":"","category":"section"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"The functions in this section compute estimates of several space and time correlation functions.  The precised definitions of the different quantities computed are summarised below.  For more details, caveats and discussion of the correlation functions we refer to the review article by T. S. Grigera[1].","category":"page"},{"location":"corr/#Time-correlations-and-correlation-time","page":"Correlation functions","title":"Time correlations and correlation time","text":"","category":"section"},{"location":"corr/#Time-correlation-function","page":"Correlation functions","title":"Time correlation function","text":"","category":"section"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"The time (auto-)correlation function of a signal a(t) (which is a noisy quantity that can be found to take different values if it is measured several times, i.e. it is a stochastic process) is defined as","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"  C(t_0t) = langle a^*(t_0) a(t_0+t) rangle","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"where a^* is the complex conjugate and brackets stands for a  history-average (an average over many realizations of the stochastic process, i.e. over many repetitions of the experiment, resetting the initial conditions).","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"The connected time correlation, or auto-covariance, is","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"   C_c(t_0t) = leftlangle delta a^*(t_0) delta a(t_0+t) rightrangle = \n   C(t_0t) - leftlangle a^*(t_0) rightrangle leftlangle a(t_0+t) rightrangle","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"where delta a(t)=a(t)-langle a(t) rangle.","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"Assume the process a(t) is sampled uniformly in time with interval Delta t.  Calling N the number of time samples and Mthe number of experiments (i.e. different measurements of a(t)  after resetting the initial conditions), we represent these data as M sequences A_i^(n) with i=1ldotsN,  n=1ldotsM.  Then the following statistical estimators of the correlation functions can be computed.","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"In the general case,","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"beginalign*\n  langle a(t_i) rangle  approx overlineA_i =frac1M sum_n=1^M A_i^(n) \n  C_c(t_it_k)  approx hat C^(c)_ik =frac1Msum_n^M delta A_i^(n)\n  delta A_i+k^(n)   qquad delta A_i^(n) = A_i^(n) - overlineA_i\nendalign*","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"If the process a(t) is stationary, then the correlation functions time-translation invariant (i.e. independent of t_0), and an estimate can be obtained with a single sample, averaging over the time origin:","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"beginalign*\n  overlineA = frac1Nsum_i=1^N A_i \n  hat C^(c)_k = frac1N-k sum_j=1^N-k delta A_j delta A_j+k\n  qquad\n  delta A_j = A_j - overlineA\nendalign*","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"Note that the estimate obtained this way is noisier the larger the value of k.","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"If the process is not stationary, then the first estimator, which needs several samples, must be used.  Although we implement this here, note that in the connected case the covariance function cov from the Statistics package can be used instead and is more convenient.  The present routine is more useful for stationary case.","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"Refer to the review article[1] for more details.","category":"page"},{"location":"corr/#Correlation-time","page":"Correlation functions","title":"Correlation time","text":"","category":"section"},{"location":"corr/#API","page":"Correlation functions","title":"API","text":"","category":"section"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"The stationary (or TTI) estimate for a single real or complex sequence is implemented with an algorithm that uses fast-Fourier-transforms, giving O(Nlog N) performance.","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"time_correlation","category":"page"},{"location":"corr/#BioStatPhys.time_correlation","page":"Correlation functions","title":"BioStatPhys.time_correlation","text":"time_correlation(A; connected=true, normalized=false, nt=nothing, i0=nothing, Amean=nothing)\n\nCompute the time (auto-)correlation function for signal A.  Returns a vector C[1:nt]\n\nA: the time signal, assumed to be sampled at evenly-spaced intervals.  If i0==nothing, it must be a Vector (real or complex), which is a single realisation or measurment of the random signal, otherwise it must be a matrix, where columns represent times and rows are different realizations of the random signal.\nIf i0==nothing (default), then A is assumed stationary (or time-translation invariant, TTI), and an estimate employing a single sequence is computed.  Otherwise, it must be an integer in the range 1<=i0<=size(A,2) and is interpreted as an index for the desired reference time.\nconnected: if true, compute the connected (i.e. subtracting the time average) correlation.\nnormalized: if true, return the result normalized by C[1].  Not recommended if non-TTI.\nnt: the maxium time difference to compute in the TTI case, otherwise ignored.  Default size(A,1)÷2.\nAmean: if connected is requested, then the signal mean can be given if known, otherwise it will be computed.\n\nIn the TTI case, an FFT-based implementation is used.\n\nIn the non-TTI, connected, case, it is probably better to use the covariance function of the Statistics package, as cov(A,dims=1).\n\n\n\n\n\n","category":"function"},{"location":"corr/#Space-correlations-and-correlation-length","page":"Correlation functions","title":"Space correlations and correlation length","text":"","category":"section"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"The space correlation functions of a space-dependent quantity a(mathbfr) are defined as","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"beginalign*\n   C(mathbfr)  = leftlangle a(mathbfr_0) a(mathbfr_0+mathbfr) rightrangle\n   C_c(mathbfr)  = leftlangle delta a(mathbfr_0) delta a(mathbfr_0+mathbfr) rightrangle\nendalign*","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"where delta a(mathbfr) = a(mathbfr) - langle arangle and we are assuming the system is homogeneous (i.e. translation-invariant).  C_c(mathbfr) is called connected correlation in the physics literature, or auto covariance in the mathematical statistics literature.","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"The space_correlation function computes the estimate of C(r) for an isotropic discrete system,","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"beginalign*\n  hat C_c(r)  = fracsum_ij delta a_i delta a_j\n    delta(r-r_ij)  sum_kl delta(r-r_kl)\nendalign*","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"The average langle arangle can be estimated with space average or phase average (see below and the review[1] for details).","category":"page"},{"location":"corr/#Correlation-length","page":"Correlation functions","title":"Correlation length","text":"","category":"section"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"The correlation length is a length scale that measures how far apart two points in space must be taken for them to be significantly decorrelated.  A good, though abstract, definition is","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"  xi = lim_rtoinfty fracr-log C_c(r)","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"which picks the slowest (i.e. longest-ranged) exponential decay rate.","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"Since this definition is not directly applicable to finite data, several alternatives have been proposed, more suited to experimental or numerical determination but respecting the functional dependence with control parameters[1].  We mention here only those that are currently implemented in BioStatPhys.","category":"page"},{"location":"corr/#r_0","page":"Correlation functions","title":"r_0","text":"","category":"section"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"If the connected correlation has been computed with space averaging, C_c(r) will have at least one zero, and the location r_0 of the first of these can be used as a proxy of xi.  We stress that r_0 is not a correlation length, but a useful scale in the case the correlation can be measured for different system sizes L (or in observation windows of different size[2]).  r_0 scales with size as[3]","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"  beginalign*\n    r_0 sim xi log(Lxi)  Lggxi \n    r_0  sim L  Lll xi\n  endalign*","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"The second situation will always be the case in scale-free systems where xi=infty.  See correlation_length_r0.","category":"page"},{"location":"corr/#API-2","page":"Correlation functions","title":"API","text":"","category":"section"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"space_correlation\ncorrelation_length_r0","category":"page"},{"location":"corr/#BioStatPhys.space_correlation","page":"Correlation functions","title":"BioStatPhys.space_correlation","text":"space_correlation(binning::DistanceBinning, X; connected=true, normalized=false, Xmean=nothing)\n\nCompute space correlation of scalar signal X in an isotropic, space-translation-invariant system using the given DistanceBinning. Since the system is assumed to be isotropic and homogeneous, correlations should depend only on the distances among the pairs, so return a tuple (r,C) where r is a vector of distances and C the correlation function at the corresponding distance.\n\nPositions are assumed to be fixed in all configurations, with only the signal changing value.\n\nX: a matrix where each column holds the signal at different positions in space and at a given time.  All columns are used to average the correlation estimate over configurations.\nbinning: instead of positions, this function expects a pre-built DistanceBinning object holding lists of pairs separated by distances in the given range, such as the binnings created by distance_binning.\nconnected: If true, compute the connected correlation, i.e. subtracting the mean of the signal.  If Xmean is nothing, space-averaging is used, i.e. at each configuration (column) the mean of X is computed and subtracted.  For phase averaging, give a precomputed mean in Xmean.\nnormalized: If true, normalize by C(r=0).\n\n\n\n\n\n","category":"function"},{"location":"corr/#BioStatPhys.correlation_length_r0","page":"Correlation functions","title":"BioStatPhys.correlation_length_r0","text":"correlation_length_r0(r,C)\n\nCompute the correlation length proxy r_0 from C_c(r) given as vectors r and C (as obtained e.g. from space_correlation(@ref).\n\nNote that r_0 is not a correlation length, just a proxy that scales with system size L as log L or L if the actual correlation length is much shorter or much larger than L respectively.\n\n\n\n\n\n","category":"function"},{"location":"corr/#References","page":"Correlation functions","title":"References","text":"","category":"section"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"[1]: T. S. Grigera, Correlation functions as a tool to study  collective behaviour phenomena in biological  systems. J. Phys. Complex. 2, 045016 (2021).  [DOI].  This review  discusses the correlation functions and estimators computed by  the routines documented here and is the general reference for  this section.","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"[2]: D. A. Martin, T. L. Ribeiro, S. A. Cannas, T. S. Grigera,  D. Plenz, and D. R. Chialvo. Box scaling as a proxy of finite  size correlations. Sci Rep 11, 15937. (2021)  [DOI]","category":"page"},{"location":"corr/","page":"Correlation functions","title":"Correlation functions","text":"[3]: A. Cavagna, I. Giardina, and T. S.  Grigera. The physics of  flocking: Correlation as a compass from experiments to  theory. Physics Reports 728, 1–62  (2018). [DOI]","category":"page"},{"location":"#BioStatPhys","page":"Home","title":"BioStatPhys","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is a collection of various tools for statistical physics analysis of experimental (and in particular biological) data.","category":"page"},{"location":"tools/#Miscellaneous-tools","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"","category":"section"},{"location":"tools/#Real-indexed-vector","page":"Miscellaneous tools","title":"Real-indexed vector","text":"","category":"section"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"This is a simple implementation of a vector that can be accessed with real (floating point) sub-indices.  It does simply a linear binning of a specified (semi-open) interval minmax) on the real line, and provides a convenient Vector-like syntax to access elements.  The stored values can be of any type, but the interval and number of bins are fixed at construction.","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"    push!(LOAD_PATH,homedir()*\"/software/BioStatPhys.jl\"); # hide\n    using BioStatPhys; # hide\n\tA = BinnedVector{String}(5,min=0.,max=1.)\n\tA[0.1]=\"hello\"\n\tA[0.2]=\"bye bye\"\n\tA","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"To initialise elements with a default value, give function with a signature like zeros: ","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"B = BinnedVector{Rational{Int64}}(10,min=2.,max=8.,init=zeros)\nB[2.1]=3//5\nB[5.3]=4//1\nB","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"Alternatively, it is possible to construct specifying bin width and the interval.  In this case, one of the values will need to be rounded to get an integer number of bins:","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"\tC = BinnedVector{Int}(Δ=0.15,min=5.,max=10.,round_Δ=RoundUp); (C.Δ, interval(C))\n\tD = BinnedVector{Int}(Δ=0.15,min=5.,max=10.,round_max=RoundUp); (D.Δ, interval(D))\n\tE = BinnedVector{Int}(Δ=0.15,min=5.,max=10.,round_min=RoundUp); (E.Δ, interval(E))","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"RoundDown is also recognised.","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"Indexing with integers refers to bin numbers.","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"\tA[1:2]\n\tB[1:5]","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"Outliers are mapped to bin 0 if below range, or -1 if above range.","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"B[0.]=10//3 ; B[40.]=99//2;\nB[0]\nB[-1]","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"The Histogram type is implemented using BinnedVector.","category":"page"},{"location":"tools/#API","page":"Miscellaneous tools","title":"API","text":"","category":"section"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"BinnedVector\ninterval\ndelta\nnbins\nbin\nbinc\nBase.range(::BinnedVector)","category":"page"},{"location":"tools/#BioStatPhys.BinnedVector","page":"Miscellaneous tools","title":"BioStatPhys.BinnedVector","text":"mutable struct BinnedVector{T}\n\nSimple real-indexed vector.  Maps a real interval to an integer range 1:nbins then used to index a vector of arbitrary type.  Can be used e.g.  to build histograms.  The real interval and number of bins nbins are fixed at the outset.\n\nExample\n\nCreate with\n\nA = BinnedVector{Int}(nbins,min=1.,max=10.,init=zeros)\n\nfor fixed number of bins, or\n\nA = BinnedVector{Int}(;Δ=0.1,min=1.,max=10.init=zeros,round_Δ=RoundUp)\nA = BinnedVector{Int}(;Δ=0.1,min=1.,max=10.init=zeros,round_min=RoundUp)\nA = BinnedVector{Int}(;Δ=0.1,min=1.,max=10.init=zeros,round_max=RoundUp)\n\nto get fixed (min, max), (Δ,max) or (min,Δ) respectively (rounding mode RoundDown is also recognised).\n\ninit is optional, defaults to leave elements undefined.\n\nAccess or write as a vector:\n\nA[5.2] += 2\n\nNumbers above and below range map to two special bins.\n\nIf indexed with integers, these are interpreted as bin numbers. A[0] and A[-1] are the outlier bins (below and above, respectively).\n\n\n\n\n\n","category":"type"},{"location":"tools/#BioStatPhys.interval","page":"Miscellaneous tools","title":"BioStatPhys.interval","text":"interval(A::BinnedVector{T})\n\nReturn tuple (min,max) giving the extrema of the real interval mapped to the array bins.\n\n\n\n\n\n","category":"function"},{"location":"tools/#BioStatPhys.delta","page":"Miscellaneous tools","title":"BioStatPhys.delta","text":"delta(A::BinnedVector{T})\n\nReturn the with of the bins of A\n\n\n\n\n\n","category":"function"},{"location":"tools/#BioStatPhys.nbins","page":"Miscellaneous tools","title":"BioStatPhys.nbins","text":"nbins(A::BinnedVector{T})\n\nReturn number of bins of A\n\n\n\n\n\n","category":"function"},{"location":"tools/#BioStatPhys.bin","page":"Miscellaneous tools","title":"BioStatPhys.bin","text":"bin(A::BinnedVector{T},x::Float64) where {T}\n\nMap real value x to bin number.  Return 0 if below range, or -1 if above range.\n\n\n\n\n\n","category":"function"},{"location":"tools/#BioStatPhys.binc","page":"Miscellaneous tools","title":"BioStatPhys.binc","text":"binc(A::BinnedVector{T},i::Int) where {T}\n\nReturn center of bin i, which must be in range 1:size(A,1). Does not perform range check.\n\n\n\n\n\n","category":"function"},{"location":"tools/#Base.range-Tuple{BinnedVector}","page":"Miscellaneous tools","title":"Base.range","text":"range(start[, stop]; length, stop, step=1)\n\nGiven a starting value, construct a range either by length or from start to stop, optionally with a given step (defaults to 1, a UnitRange). One of length or stop is required.  If length, stop, and step are all specified, they must agree.\n\nIf length and stop are provided and step is not, the step size will be computed automatically such that there are length linearly spaced elements in the range.\n\nIf step and stop are provided and length is not, the overall range length will be computed automatically such that the elements are step spaced.\n\nSpecial care is taken to ensure intermediate values are computed rationally. To avoid this induced overhead, see the LinRange constructor.\n\nstop may be specified as either a positional or keyword argument.\n\ncompat: Julia 1.1\nstop as a positional argument requires at least Julia 1.1.\n\nExamples\n\njulia> range(1, length=100)\n1:100\n\njulia> range(1, stop=100)\n1:100\n\njulia> range(1, step=5, length=100)\n1:5:496\n\njulia> range(1, step=5, stop=100)\n1:5:96\n\njulia> range(1, 10, length=101)\n1.0:0.09:10.0\n\njulia> range(1, 100, step=5)\n1:5:96\n\n\n\n\n\nBase.range(A::BinnedVector{T}) where{T}\n\nReturn range spanning bin centers of A.  With r=collect(range(A)) one obtains a Vector such that r[i]=binc(A,i)\n\n\n\n\n\n","category":"method"},{"location":"tools/#Distance-binning","page":"Miscellaneous tools","title":"Distance binning","text":"","category":"section"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"The distance_binning function takes a series of points in (2- or 3-d) space and creates a BinnedVector that classifies the pairs according to their Euclidean distance.","category":"page"},{"location":"tools/","page":"Miscellaneous tools","title":"Miscellaneous tools","text":"DistanceBinning\ndistance_binning","category":"page"},{"location":"tools/#BioStatPhys.DistanceBinning","page":"Miscellaneous tools","title":"BioStatPhys.DistanceBinning","text":"Alias for a BinnedVector of Vector{Tuple{Int,Int}}\n\n\n\n\n\n","category":"type"},{"location":"tools/#BioStatPhys.distance_binning","page":"Miscellaneous tools","title":"BioStatPhys.distance_binning","text":"distance_binning(pos,Δr;rmin=0.,rmax=nothing)\n\nCreate a BinnedVector of tuples (i,j) with i!=j, where each bin contains all pairs of positions in pos whose distance is within the bin extrema.\n\npos is expected to be a Matrix where each row pos[i,:] is a 2-d or 3-d position vector.\n\n\n\n\n\n","category":"function"}]
}
