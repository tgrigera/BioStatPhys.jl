<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Correlation functions · BioStatPhys.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BioStatPhys.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../stat/">Statistical tools</a></li><li class="is-active"><a class="tocitem" href>Correlation functions</a><ul class="internal"><li><a class="tocitem" href="#Time-correlations-and-correlation-time"><span>Time correlations and correlation time</span></a></li><li><a class="tocitem" href="#Density-correlations"><span>Density correlations</span></a></li><li><a class="tocitem" href="#Space-correlations-and-correlation-length"><span>Space correlations and correlation length</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../tools/">Miscellaneous tools</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Correlation functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Correlation functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tgrigera/BioStatPhys.jl/blob/main/docs/src/corr.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Correlation-functions"><a class="docs-heading-anchor" href="#Correlation-functions">Correlation functions</a><a id="Correlation-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Correlation-functions" title="Permalink"></a></h1><p>The functions in this section compute estimates of several space and time correlation functions.  The precised definitions of the different quantities computed are summarised below.  For more details, caveats and discussion of the correlation functions we refer to the review article by T. S. Grigera<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.</p><h2 id="Time-correlations-and-correlation-time"><a class="docs-heading-anchor" href="#Time-correlations-and-correlation-time">Time correlations and correlation time</a><a id="Time-correlations-and-correlation-time-1"></a><a class="docs-heading-anchor-permalink" href="#Time-correlations-and-correlation-time" title="Permalink"></a></h2><h3 id="Time-correlation-function"><a class="docs-heading-anchor" href="#Time-correlation-function">Time correlation function</a><a id="Time-correlation-function-1"></a><a class="docs-heading-anchor-permalink" href="#Time-correlation-function" title="Permalink"></a></h3><p>The <em>time (auto-)correlation function</em> of a signal <span>$a(t)$</span> (which is a noisy quantity that can be found to take different values if it is measured several times, i.e. it is a stochastic process) is defined as</p><p class="math-container">\[  C(t_0,t) = \langle a^*(t_0) a(t_0+t) \rangle,\]</p><p>where <span>$a^*$</span> is the complex conjugate and brackets stands for a  history-average (an average over many realizations of the stochastic process, i.e. over many repetitions of the experiment, resetting the initial conditions).</p><p>The <em>connected time correlation</em>, or <em>auto-covariance</em>, is</p><p class="math-container">\[   C_c(t_0,t) = \left\langle \delta a^*(t_0) \delta a(t_0+t) \right\rangle = 
   C(t_0,t) - \left\langle a^*(t_0) \right\rangle \left\langle a(t_0+t) \right\rangle,\]</p><p>where <span>$\delta a(t)=a(t)-\langle a(t) \rangle$</span>.</p><p>Assume the process <span>$a(t)$</span> is sampled uniformly in time with interval <span>$\Delta t$</span>.  Calling <span>$N$</span> the number of time samples and <span>$M$</span>the number of experiments (i.e. different measurements of <span>$a(t)$</span>  after resetting the initial conditions), we represent these data as <span>$M$</span> sequences <span>$A_i^{(n)}$</span> with <span>$i=1,\ldots,N$</span>,  <span>$n=1,\ldots,M$</span>.  Then the following statistical estimators of the correlation functions can be computed.</p><p>In the general case,</p><p class="math-container">\[\begin{align*}
  \langle a(t_i) \rangle &amp; \approx \overline{A_i} =\frac{1}{M} \sum_{n=1}^M A_i^{(n)}, \\
  C_c(t_i,t_k) &amp; \approx \hat C^{(c)}_{i,k} =\frac{1}{M}\sum_n^M \delta A_i^{(n)}
  \delta A_{i+k}^{(n)}  , \qquad \delta A_i^{(n)} = A_i^{(n)} - \overline{A_i}.
\end{align*}\]</p><p>If the process <span>$a(t)$</span> is stationary, then the correlation functions time-translation invariant (i.e. independent of <span>$t_0$</span>), and an estimate can be obtained with a single sample, averaging over the time origin:</p><p class="math-container">\[\begin{align*}
  \overline{A} &amp;= \frac{1}{N}\sum_{i=1}^N A_i, \\
  \hat C^{(c)}_k &amp;= \frac{1}{N-k} \sum_{j=1}^{N-k} \delta A_j \delta A_{j+k},
  \qquad
  \delta A_j = A_j - \overline{A}.
\end{align*}\]</p><p>Note that the estimate obtained this way is noisier the larger the value of <span>$k$</span>.</p><p>If the process is not stationary, then the first estimator, which needs several samples, must be used.  Although we implement this here, note that in the connected case the covariance function <code>cov</code> from the <code>Statistics</code> package can be used instead and is more convenient.  The present routine is more useful for stationary case.</p><p>Refer to the review article<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> for more details.</p><h3 id="Correlation-time"><a class="docs-heading-anchor" href="#Correlation-time">Correlation time</a><a id="Correlation-time-1"></a><a class="docs-heading-anchor-permalink" href="#Correlation-time" title="Permalink"></a></h3><p>The <em>correlation time</em> is a time scale that measures how separated in time two measurements must be for them to be significantly decorrelated.  A good, though abstract, definition is</p><p class="math-container">\[  \tau = \lim_{t\to\infty} \frac{t}{-\log C_c(t)}.\]</p><p>which picks the slowest (i.e. longest-ranged) exponential decay rate (cf <a href="#Correlation-length">Correlation length</a>).</p><p>Since this definition is not directly applicable to finite data, several practical alternatives have been proposed<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.  We mention here only those that are currently implemented in <code>BioStatPhys</code>.</p><h4 id="Spectral-correlation-time"><a class="docs-heading-anchor" href="#Spectral-correlation-time">Spectral correlation time</a><a id="Spectral-correlation-time-1"></a><a class="docs-heading-anchor-permalink" href="#Spectral-correlation-time" title="Permalink"></a></h4><p>The spectral correlation time <span>$\tau_S$</span> is defined as the inverse of the frequency <span>$\omega_0$</span> such that half the spectral content of the Fourier transform of the connected correlation <span>$C_c(t)$</span> is contained in the interval <span>$[-\omega_0,\omega_0]$</span>.  Translated to the time domain, the definition is</p><p class="math-container">\[ \int_0^\infty \!\!dt \, \frac{C_c(t)}{C_c(0)} \frac{\sin t/\tau}{t} = \frac{\pi}{4}\]</p><p>This is computed by <a href="#BioStatPhys.correlation_time_spectral"><code>correlation_time_spectral</code></a>.</p><h3 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h3><p>The stationary (or TTI) estimate for a single real or complex sequence is implemented with an algorithm that uses fast-Fourier-transforms, giving <span>$O(N\log N)$</span> performance.</p><article class="docstring"><header><a class="docstring-binding" id="BioStatPhys.time_correlation" href="#BioStatPhys.time_correlation"><code>BioStatPhys.time_correlation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">time_correlation(A; connected=true, normalized=false, nt=nothing, i0=nothing, Amean=nothing)</code></pre><p>Compute the time (auto-)correlation function for signal <code>A</code>.  Returns a vector <code>C[1:nt]</code></p><ul><li><p><code>A</code>: the time signal, assumed to be sampled at evenly-spaced intervals.  If <code>i0==nothing</code>, it must be a <code>Vector</code> (real or complex), which is a single realisation or measurment of the random signal, otherwise it must be a matrix, where columns represent times and rows are different realizations of the random signal.</p></li><li><p>If <code>i0==nothing</code> (default), then <code>A</code> is assumed stationary (or time-translation invariant, TTI), and an estimate employing a single sequence is computed.  Otherwise, it must be an integer in the range <code>1&lt;=i0&lt;=size(A,2)</code> and is interpreted as an index for the desired reference time.</p></li><li><p><code>connected</code>: if true, compute the connected (i.e. subtracting the time average) correlation.</p></li><li><p><code>normalized</code>: if true, return the result normalized by <code>C[1]</code>.  Not recommended if non-TTI.</p></li><li><p><code>nt</code>: the maxium time difference to compute in the TTI case, otherwise ignored.  Default <code>size(A,1)÷2</code>.</p></li><li><p><code>Amean</code>: if <code>connected</code> is requested, then the signal mean can be given if known, otherwise it will be computed.</p></li></ul><p>In the TTI case, an FFT-based implementation is used.</p><p>In the non-TTI, connected, case, it is probably better to use the covariance function of the <code>Statistics</code> package, as <code>cov(A,dims=1)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tgrigera/BioStatPhys.jl/blob/193d8e5e792daac8288e7185792083fb8b559c6a/src/stat/timecorr.jl#L20-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BioStatPhys.correlation_time_spectral" href="#BioStatPhys.correlation_time_spectral"><code>BioStatPhys.correlation_time_spectral</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">correlation_time_spectral(C,Δt)</code></pre><p>Compute the spectral correlation time <span>$\tau$</span> from the connected time correlation <code>C</code> (e.g. as computed by <a href="#BioStatPhys.time_correlation"><code>time_correlation</code></a>).  The scalar <code>Δt</code> is the time step for the sampling of <code>C</code>.</p><p>The exact definition <span>$\tau$</span> is</p><p class="math-container">\[ \int_0^\infty \!\!dt \, \frac{C_c(t)}{C_c(0)} \frac{\sin t/\tau}{t} = \frac{\pi}{4}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tgrigera/BioStatPhys.jl/blob/193d8e5e792daac8288e7185792083fb8b559c6a/src/stat/timecorr.jl#L176-L188">source</a></section></article><h2 id="Density-correlations"><a class="docs-heading-anchor" href="#Density-correlations">Density correlations</a><a id="Density-correlations-1"></a><a class="docs-heading-anchor-permalink" href="#Density-correlations" title="Permalink"></a></h2><p>Here we consider point-like particles in continuous space.  The (instantaneous) density of a given configuration <span>$\{\mathbf{r}_i\}$</span> is</p><p class="math-container">\[\begin{equation*}
\rho(\mathbf{r}) = \sum_{i=1}^N \delta(\mathbf{r}-\mathbf{r}_i),
\end{equation*}\]</p><p>where <span>$\delta(\mathbf{r})$</span> is Dirac&#39;s delta.  The <em>density-density correlation function</em> is</p><p class="math-container">\[ G(\mathbf{r},\mathbf{r}_0) = \langle \rho(\mathbf{r}_0) \rho(\mathbf{r}_0+\mathbf{r})\rangle = \left\langle \sum_{i,j} \delta(\mathbf{r}_0-\mathbf{r}_i),\delta(\mathbf{r}_0+\mathbf{r}-\mathbf{r}_i) \right\rangle =
\frac{1}{V} \left\langle \sum_{i,j} \delta(\mathbf{r}-(\mathbf{r}_i-\mathbf{r}_j)) \right\rangle, \]</p><p>where the last equality holds for homogeneous systems.  The angle brackets denote an ensemble average, i.e. an average over configurations weighted with the appropriate probability distribution (e.g. Boltzmann&#39;s distribution in a physical system in equilibrium).</p><p>The routines in this section compute the density-density correlation function and a couple of other, related and very often used, correlation functions, for the case of homogeneous and isotropic systems in several geometries.</p><p>The other correlation functions computed are the <em>radial distribution function</em></p><p class="math-container">\[g(r) = \frac{1}{\rho^2}G(r) - \frac{\delta(r)}{4\pi\rho r^2}
 = \frac{1}{\rho N} \left\langle \sum_{ij} \delta\left( r - r_{ij}\right) \right\rangle.\]</p><p>and the <em>correlation integral</em></p><p class="math-container">\[ C(r) = \frac{\rho}{N} \int_0^r \!\!G(r&#39;)\,dr&#39; = \frac{1}{N^2} \left\langle \sum_{ij} \Theta(r-r_{ij}) \right\rangle,\]</p><p>where <span>$\Theta(r)$</span> is Heavisde&#39;s function.</p><p>The computation is done in two steps.  First an internal <code>DensityCorrelation</code> object is built from a set of configurations, then the desired correlation is computed passing this object.  The first step is slow (<span>$O(N^2)$</span>), while the second is fast.  To build the <code>DensityCorrelation</code> object one needs to load one configuration in a vector of vectors and define the region (see <a href="../tools/#Regions">Regions</a>) in which the particles lie, then call <code>density_correlation</code>, specifying the desired range and resolution.  If more configurations are available, they can be added by calls to <code>density_correlation!</code>.  Finally, the desired correlation function is computed.  For example:</p><pre><code class="language-julia hljs">pos = load_conf()
region = Rectangle(pos)
dc = density_correlation(region,pos,0.1,rmax=10.)
while more_confs()
   pos = load_conf()
   density_correlation!(dc,pos)
end
gr, Cr = rdf(pc)</code></pre><p>The <code>DensityCorrelation</code> object is not altered by calling <code>rdf</code> and the like, so that more statics can be added by further calls to <code>density_correlation</code>.  Internally, different subtypes of <code>DensityCorrelation</code> are used for different regions, so that the different cases are handled correctly.  In particular, for non-periodic regions, the <em>unweighted Hanisch</em> <sup class="footnote-reference"><a id="citeref-4" href="#footnote-4">[4]</a></sup><sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> method is used.</p><p>Configurations are interpreted as a vector of vectors, where each element is a vector of the size equal to the dimension of the region being used.  The functions expect <code>AbstactVector</code>s, so for example both <code>Vector{Vector{Float64}</code> and <code>Vector{SVector{2,Float64}}</code> are valid types for a 2-dimensional region, but the latter (using <code>StaticArrays</code>) can be much more efficient.</p><h3 id="Fluctuating-number-of-particles"><a class="docs-heading-anchor" href="#Fluctuating-number-of-particles">Fluctuating number of particles</a><a id="Fluctuating-number-of-particles-1"></a><a class="docs-heading-anchor-permalink" href="#Fluctuating-number-of-particles" title="Permalink"></a></h3><p><code>density_correlation!</code> accepts configurations with different number of particles.  In this case, <code>rdf</code> will compute <span>$g(r)$</span> using the definition for the grand canonical ensemble, which for homogeneous systems is <sup class="footnote-reference"><a id="citeref-5" href="#footnote-5">[5]</a></sup></p><p class="math-container">\[  g(r) = \frac{\rho^{(2)}(r)}{\rho^2}, \qquad \rho^{(2)} = \sum_N p(N) \rho_N^{(2)},\]</p><p>where <span>$p(N)$</span> is the probability of finding a configuration with <span>$N$</span> particles, and <span>$\rho_N^{(2)}(r) = \rho_N^2 g_N(r) = (N/V)^2 g_N(r)$</span>.  Note that this is not the same as averaging <span>$g(r)$</span> over configurations.  In particular, for completely uncorrelated systems one gets <span>$g(r) \to \langle \rho^2\rangle / \left(\langle\rho\rangle\right)^2$</span>, which is equal to one in the grand canonical ensemble in the thermodynamic limit, but is larger than 1 in general.  It is up to you to decide whether you need this or an average over the radial distribution function.</p><h3 id="API-2"><a class="docs-heading-anchor" href="#API-2">API</a><a class="docs-heading-anchor-permalink" href="#API-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="BioStatPhys.density_correlation" href="#BioStatPhys.density_correlation"><code>BioStatPhys.density_correlation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">density_correlation(region,pos;Δr,rmax)</code></pre><p>Return a <code>Density_correlation</code> object for the given <code>region</code> and configuration <code>pos</code>, with resolution <code>Δr</code> and maximum range <code>rmax</code>. The returned object can be passed to the functions that compute the final correlations, such as <code>rdf</code>, or more configurations can be added to it by calling <code>density_correlation(::DensityCorrelation,pos)</code>.</p><p><code>pos</code> must be a vector of vectors, i.e. each element of <code>pos</code> must be a vector of the appropriate dimensionality.  Performance advantage may be obtained using <code>StaticArrays</code> to represent individual positions. More precisely, the type of <code>pos</code> is</p><pre><code class="nohighlight hljs">AbstractVector{T} where T&lt;:AbstractVector{W} where W&lt;:Number</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tgrigera/BioStatPhys.jl/blob/193d8e5e792daac8288e7185792083fb8b559c6a/src/stat/spacecorr.jl#L336-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BioStatPhys.density_correlation!" href="#BioStatPhys.density_correlation!"><code>BioStatPhys.density_correlation!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">density_correlation!(dcorr::Density_correlation{R},pos) where R &lt;: Region</code></pre><p>Use configuration <code>pos</code> to add statistics to the <code>DensityCorrelation</code> object <code>dcorr</code>.  The configuration need not have the same number of particles as those used previously, but check with functions <code>rdf</code> and the like how these fluctuations are treated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tgrigera/BioStatPhys.jl/blob/193d8e5e792daac8288e7185792083fb8b559c6a/src/stat/spacecorr.jl#L368-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BioStatPhys.rdf" href="#BioStatPhys.rdf"><code>BioStatPhys.rdf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rdf(dcorr::Density_correlation{R};two_particle_density=false)</code></pre><p>If <code>two_particle_density</code>is <code>false</code> (default), compute the radial distribution function <span>$g(r)$</span> and the correlation integral <span>$C(r)$</span>. Both are returned as a tuple of <code>ZBinnedVector</code>.</p><p>If <code>two_particle_density</code> is <code>true</code>, return the density-density correlation function <span>$G(r)$</span> instead of <span>$g(r)$</span>.  For the isotropic case assumed here, <span>$G(r) = \rho^2 g(r) + \rho \delta(r)/4\pi r^2$</span> (in 3-d).  Since <span>$G(r)$</span> is singular at <span>$r=0$</span>, here for <span>$r=0$</span> we return <span>$\rho$</span>, i.e. the integral of <span>$G(r)$</span> in a very small volume around the origin.</p><p>If the <code>dcorr</code> object was fed with configurations with fluctuating number of particles, then the radial distribution function will be computed using the definition for the grand canonical ensamble (see J.-P. Hansen and I. R. McDonald, <em>Theory of Simple Liquids</em>, Academic Press (2005)).  This may or may not be what you want.  See the online documentation of the package for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tgrigera/BioStatPhys.jl/blob/193d8e5e792daac8288e7185792083fb8b559c6a/src/stat/spacecorr.jl#L388-L408">source</a></section></article><h2 id="Space-correlations-and-correlation-length"><a class="docs-heading-anchor" href="#Space-correlations-and-correlation-length">Space correlations and correlation length</a><a id="Space-correlations-and-correlation-length-1"></a><a class="docs-heading-anchor-permalink" href="#Space-correlations-and-correlation-length" title="Permalink"></a></h2><p>The space correlation functions of a space-dependent quantity <span>$a(\mathbf{r})$</span> are defined as</p><p class="math-container">\[\begin{align*}
   C(\mathbf{r}) &amp; = \left\langle a(\mathbf{r_0}) a(\mathbf{r_0}+\mathbf{r}) \right\rangle,\\
   C_c(\mathbf{r}) &amp; = \left\langle \delta a(\mathbf{r_0}) \delta a(\mathbf{r_0}+\mathbf{r}) \right\rangle,
\end{align*}\]</p><p>where <span>$\delta a(\mathbf{r}) = a(\mathbf{r}) - \langle a\rangle$</span> and we are assuming the system is homogeneous (i.e. translation-invariant).  <span>$C_c(\mathbf{r})$</span> is called <em>connected</em> correlation in the physics literature, or <em>auto covariance</em> in the mathematical statistics literature.</p><p>The <a href="#BioStatPhys.space_correlation"><code>space_correlation</code></a> function computes the estimate of <span>$C(r)$</span> for an isotropic discrete system,</p><p class="math-container">\[\begin{align*}
  \hat C_c(r) &amp; = \frac{\sum_{ij} \delta a_i \delta a_j
    \delta(r-r_{ij}) } {\sum_{kl} \delta(r-r_{kl})}.
\end{align*}\]</p><p>The average <span>$\langle a\rangle$</span> can be estimated with space average or phase average (see below and the review<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> for details).</p><h3 id="Correlation-length"><a class="docs-heading-anchor" href="#Correlation-length">Correlation length</a><a id="Correlation-length-1"></a><a class="docs-heading-anchor-permalink" href="#Correlation-length" title="Permalink"></a></h3><p>The <em>correlation length</em> is a length scale that measures how far apart two points in space must be taken for them to be significantly decorrelated.  A good, though abstract, definition is</p><p class="math-container">\[  \xi = \lim_{r\to\infty} \frac{r}{-\log C_c(r)},\]</p><p>which picks the slowest (i.e. longest-ranged) exponential decay rate (cf. <a href="#Correlation-time">Correlation time</a>).</p><p>Since this definition is not directly applicable to finite data, several alternatives have been proposed, more suited to experimental or numerical determination but respecting the functional dependence with control parameters<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.  We mention here only those that are currently implemented in <code>BioStatPhys</code>.</p><h4 id="r_0"><a class="docs-heading-anchor" href="#r_0"><span>$r_0$</span></a><a id="r_0-1"></a><a class="docs-heading-anchor-permalink" href="#r_0" title="Permalink"></a></h4><p>If the connected correlation has been computed with space averaging, <span>$C_c(r)$</span> will have at least one zero, and the location <span>$r_0$</span> of the first of these can be used as a proxy of <span>$\xi$</span>.  We stress that <span>$r_0$</span> is <strong>not</strong> a correlation length, but a useful scale in the case the correlation can be measured for different system sizes <span>$L$</span> (or in observation windows of different size<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>).  <span>$r_0$</span> scales with size as<sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup></p><p class="math-container">\[  \begin{align*}
    r_0 &amp;\sim \xi \log(L/\xi), &amp; L\gg\xi, \\
    r_0 &amp; \sim L, &amp; L\ll \xi.
  \end{align*}\]</p><p>The second situation will always be the case in scale-free systems where <span>$\xi=\infty$</span>.  See <a href="#BioStatPhys.correlation_length_r0"><code>correlation_length_r0</code></a>.</p><h3 id="API-3"><a class="docs-heading-anchor" href="#API-3">API</a><a class="docs-heading-anchor-permalink" href="#API-3" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="BioStatPhys.space_correlation" href="#BioStatPhys.space_correlation"><code>BioStatPhys.space_correlation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">space_correlation(binning::DistanceBinning, X; connected=true, normalized=false, Xmean=nothing)</code></pre><p>Compute space correlation of scalar signal <code>X</code> in an isotropic, space-translation-invariant system using the given <code>DistanceBinning</code>. Since the system is assumed to be isotropic and homogeneous, correlations should depend only on the distances among the pairs, so return a tuple <code>(r,C)</code> where <code>r</code> is a vector of distances and <code>C</code> the correlation function at the corresponding distance.</p><p>Positions are assumed to be fixed in all configurations, with only the signal changing value.</p><ul><li><p><code>X</code>: a matrix where each column holds the signal at different positions in space and at a given time.  All columns are used to average the correlation estimate over configurations.</p></li><li><p><code>binning</code>: instead of positions, this function expects a pre-built <a href="../tools/#BioStatPhys.DistanceBinning"><code>DistanceBinning</code></a> object holding lists of pairs separated by distances in the given range, such as the binnings created by <a href="../tools/#BioStatPhys.distance_binning"><code>distance_binning</code></a>.</p></li><li><p><code>connected</code>: If true, compute the connected correlation, i.e. subtracting the mean of the signal.  If <code>Xmean</code> is <code>nothing</code>, space-averaging is used, i.e. at each configuration (column) the mean of <code>X</code> is computed and subtracted.  For phase averaging, give a precomputed mean in <code>Xmean</code>.</p></li><li><p><code>normalized</code>: If <code>true</code>, normalize by <span>$C(r=0)$</span>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tgrigera/BioStatPhys.jl/blob/193d8e5e792daac8288e7185792083fb8b559c6a/src/stat/spacecorr.jl#L19-L49">source</a></section><section><div><pre><code class="nohighlight hljs">space_correlation(region::Region,Δr;rmax=nothing,connected=false)
space_correlation(region::Region,pos::ConfigurationT,Δr;rmax=nothing,connected=false)</code></pre><p>Build and return a <code>Space_correlation_vectorqty</code> object to compute space correlations of some vectorial observable.  If <code>pos</code> is given, it will be assumed that positions will be the same for all configurations, and a <code>DistanceBinning</code> object will be built to save time later.  If posiitons change with every configuration, then omit this argument.</p><p>To add data to an object <code>corr</code>, call</p><pre><code class="nohighlight hljs">space_correlation!(corr,pos,vec)</code></pre><p>or</p><pre><code class="nohighlight hljs">space_correlation!(corr,vec)</code></pre><p>if particles are static.  Correlation functions are obtained calling <code>correlations(corr)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tgrigera/BioStatPhys.jl/blob/193d8e5e792daac8288e7185792083fb8b559c6a/src/stat/spacecorr.jl#L102-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BioStatPhys.correlation_length_r0" href="#BioStatPhys.correlation_length_r0"><code>BioStatPhys.correlation_length_r0</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">correlation_length_r0(r,C)</code></pre><p>Compute the correlation length proxy <span>$r_0$</span> from <span>$C_c(r)$</span> given as vectors <code>r</code> and <code>C</code> (as obtained e.g. from <code>space_correlation</code>(@ref).</p><p>Note that <span>$r_0$</span> is <strong>not</strong> a correlation length, just a proxy that scales with system size <span>$L$</span> as <span>$\log L$</span> or <span>$L$</span> if the actual correlation length is much shorter or much larger than <span>$L$</span> respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tgrigera/BioStatPhys.jl/blob/193d8e5e792daac8288e7185792083fb8b559c6a/src/stat/spacecorr.jl#L487-L497">source</a></section></article><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>T. S. Grigera, Correlation functions as a tool to study  collective behaviour phenomena in biological  systems. <em>J. Phys. Complex.</em> <strong>2,</strong> 045016 (2021).  [<a href="https://doi.org/10.1088/2632-072X/ac2b06">DOI</a>].  This review  discusses the correlation functions and estimators computed by  the routines documented here and is the general reference for  this section.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>D. A. Martin, T. L. Ribeiro, S. A. Cannas, T. S. Grigera,  D. Plenz, and D. R. Chialvo. Box scaling as a proxy of finite  size correlations. <em>Sci Rep</em> <strong>11,</strong> 15937. (2021)  [<a href="http://dx.doi.org/10.1038/s41598-021-95595-2">DOI</a>]</li><li class="footnote" id="footnote-3"><a class="tag is-link" href="#citeref-3">3</a>A. Cavagna, I. Giardina, and T. S.  Grigera. The physics of  flocking: Correlation as a compass from experiments to  theory. <em>Physics Reports</em> <strong>728,</strong> 1–62  (2018). [<a href="http://dx.doi.org/10.1016/j.physrep.2017.11.003">DOI</a>]</li><li class="footnote" id="footnote-4"><a class="tag is-link" href="#citeref-4">4</a>K. H. Hanisch, Some remarks on estimators of the distribution  function of nearest neighbour distance in stationary spatial  point processes. <em>Ser. Stat.</em> <strong>15</strong>, 409 (1984). [<a href="http://dx.doi.org/10.1080/02331888408801788">DOI</a>]</li><li class="footnote" id="footnote-5"><a class="tag is-link" href="#citeref-5">5</a>J.-P. Hansen and I. R. McDonald, <em>Theory of Simple Liquids</em>,  Academic Press (2005)</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../stat/">« Statistical tools</a><a class="docs-footer-nextpage" href="../tools/">Miscellaneous tools »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 11 June 2025 12:23">Wednesday 11 June 2025</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
